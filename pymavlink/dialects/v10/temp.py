'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: temp.xml,ardupilotmega.xml

Note: this file has been auto-generated. DO NOT EDIT
'''

import struct, array, time, json, os, sys, platform

from ...generator.mavcrc import x25crc

WIRE_PROTOCOL_VERSION = "1.0"
DIALECT = "temp"

native_supported = platform.system() != 'Windows' # Not yet supported on other dialects
native_force = 'MAVNATIVE_FORCE' in os.environ # Will force use of native code regardless of what client app wants
native_testing = 'MAVNATIVE_TESTING' in os.environ # Will force both native and legacy code to be used and their results compared

if native_supported:
    try:
        import mavnative
    except ImportError:
        print("ERROR LOADING MAVNATIVE - falling back to python implementation")
        native_supported = False

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId

    def pack(self):
        return struct.pack('BBBBBB', 254, self.mlen, self.seq,
                          self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = getattr(self, a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other == None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False            

        if self.get_srcComponent() != other.get_srcComponent():
            return False   
            
        for a in self._fieldnames:
            if getattr(self, a) != getattr(other, a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = getattr(self, a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def pack(self, mav, crc_extra, payload):
        self._payload = payload
        self._header  = MAVLink_header(self._header.msgId, len(payload), mav.seq,
                                       mav.srcSystem, mav.srcComponent)
        self._msgbuf = self._header.pack() + payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(chr(crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        return self._msgbuf


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}
        
enums = {}

# MAV_CMD
enums['MAV_CMD'] = {}
MAV_CMD_DO_MOTOR_TEST = 209 # Mission command to perform motor test
enums['MAV_CMD'][209] = EnumEntry('MAV_CMD_DO_MOTOR_TEST', '''Mission command to perform motor test''')
enums['MAV_CMD'][209].param[1] = '''motor sequence number (a number from 1 to max number of motors on the vehicle)'''
enums['MAV_CMD'][209].param[2] = '''throttle type (0=throttle percentage, 1=PWM, 2=pilot throttle channel pass-through. See MOTOR_TEST_THROTTLE_TYPE enum)'''
enums['MAV_CMD'][209].param[3] = '''throttle'''
enums['MAV_CMD'][209].param[4] = '''timeout (in seconds)'''
enums['MAV_CMD'][209].param[5] = '''Empty'''
enums['MAV_CMD'][209].param[6] = '''Empty'''
enums['MAV_CMD'][209].param[7] = '''Empty'''
MAV_CMD_DO_GRIPPER = 211 # Mission command to operate EPM gripper
enums['MAV_CMD'][211] = EnumEntry('MAV_CMD_DO_GRIPPER', '''Mission command to operate EPM gripper''')
enums['MAV_CMD'][211].param[1] = '''gripper number (a number from 1 to max number of grippers on the vehicle)'''
enums['MAV_CMD'][211].param[2] = '''gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum)'''
enums['MAV_CMD'][211].param[3] = '''Empty'''
enums['MAV_CMD'][211].param[4] = '''Empty'''
enums['MAV_CMD'][211].param[5] = '''Empty'''
enums['MAV_CMD'][211].param[6] = '''Empty'''
enums['MAV_CMD'][211].param[7] = '''Empty'''
MAV_CMD_DO_START_MAG_CAL = 42424 # Initiate a magnetometer calibration
enums['MAV_CMD'][42424] = EnumEntry('MAV_CMD_DO_START_MAG_CAL', '''Initiate a magnetometer calibration''')
enums['MAV_CMD'][42424].param[1] = '''uint8_t bitmask of magnetometers (0 means all)'''
enums['MAV_CMD'][42424].param[2] = '''Automatically retry on failure (0=no retry, 1=retry).'''
enums['MAV_CMD'][42424].param[3] = '''Save without user input (0=require input, 1=autosave).'''
enums['MAV_CMD'][42424].param[4] = '''Delay (seconds)'''
enums['MAV_CMD'][42424].param[5] = '''Empty'''
enums['MAV_CMD'][42424].param[6] = '''Empty'''
enums['MAV_CMD'][42424].param[7] = '''Empty'''
MAV_CMD_DO_ACCEPT_MAG_CAL = 42425 # Initiate a magnetometer calibration
enums['MAV_CMD'][42425] = EnumEntry('MAV_CMD_DO_ACCEPT_MAG_CAL', '''Initiate a magnetometer calibration''')
enums['MAV_CMD'][42425].param[1] = '''uint8_t bitmask of magnetometers (0 means all)'''
enums['MAV_CMD'][42425].param[2] = '''Empty'''
enums['MAV_CMD'][42425].param[3] = '''Empty'''
enums['MAV_CMD'][42425].param[4] = '''Empty'''
enums['MAV_CMD'][42425].param[5] = '''Empty'''
enums['MAV_CMD'][42425].param[6] = '''Empty'''
enums['MAV_CMD'][42425].param[7] = '''Empty'''
MAV_CMD_DO_CANCEL_MAG_CAL = 42426 # Cancel a running magnetometer calibration
enums['MAV_CMD'][42426] = EnumEntry('MAV_CMD_DO_CANCEL_MAG_CAL', '''Cancel a running magnetometer calibration''')
enums['MAV_CMD'][42426].param[1] = '''uint8_t bitmask of magnetometers (0 means all)'''
enums['MAV_CMD'][42426].param[2] = '''Empty'''
enums['MAV_CMD'][42426].param[3] = '''Empty'''
enums['MAV_CMD'][42426].param[4] = '''Empty'''
enums['MAV_CMD'][42426].param[5] = '''Empty'''
enums['MAV_CMD'][42426].param[6] = '''Empty'''
enums['MAV_CMD'][42426].param[7] = '''Empty'''
MAV_CMD_ENUM_END = 42427 # 
enums['MAV_CMD'][42427] = EnumEntry('MAV_CMD_ENUM_END', '''''')

# LIMITS_STATE
enums['LIMITS_STATE'] = {}
LIMITS_INIT = 0 #  pre-initialization
enums['LIMITS_STATE'][0] = EnumEntry('LIMITS_INIT', ''' pre-initialization''')
LIMITS_DISABLED = 1 #  disabled
enums['LIMITS_STATE'][1] = EnumEntry('LIMITS_DISABLED', ''' disabled''')
LIMITS_ENABLED = 2 #  checking limits
enums['LIMITS_STATE'][2] = EnumEntry('LIMITS_ENABLED', ''' checking limits''')
LIMITS_TRIGGERED = 3 #  a limit has been breached
enums['LIMITS_STATE'][3] = EnumEntry('LIMITS_TRIGGERED', ''' a limit has been breached''')
LIMITS_RECOVERING = 4 #  taking action eg. RTL
enums['LIMITS_STATE'][4] = EnumEntry('LIMITS_RECOVERING', ''' taking action eg. RTL''')
LIMITS_RECOVERED = 5 #  we're no longer in breach of a limit
enums['LIMITS_STATE'][5] = EnumEntry('LIMITS_RECOVERED', ''' we're no longer in breach of a limit''')
LIMITS_STATE_ENUM_END = 6 # 
enums['LIMITS_STATE'][6] = EnumEntry('LIMITS_STATE_ENUM_END', '''''')

# LIMIT_MODULE
enums['LIMIT_MODULE'] = {}
LIMIT_GPSLOCK = 1 #  pre-initialization
enums['LIMIT_MODULE'][1] = EnumEntry('LIMIT_GPSLOCK', ''' pre-initialization''')
LIMIT_GEOFENCE = 2 #  disabled
enums['LIMIT_MODULE'][2] = EnumEntry('LIMIT_GEOFENCE', ''' disabled''')
LIMIT_ALTITUDE = 4 #  checking limits
enums['LIMIT_MODULE'][4] = EnumEntry('LIMIT_ALTITUDE', ''' checking limits''')
LIMIT_MODULE_ENUM_END = 5 # 
enums['LIMIT_MODULE'][5] = EnumEntry('LIMIT_MODULE_ENUM_END', '''''')

# RALLY_FLAGS
enums['RALLY_FLAGS'] = {}
FAVORABLE_WIND = 1 # Flag set when requiring favorable winds for landing.
enums['RALLY_FLAGS'][1] = EnumEntry('FAVORABLE_WIND', '''Flag set when requiring favorable winds for landing. ''')
LAND_IMMEDIATELY = 2 # Flag set when plane is to immediately descend to break altitude and
                        # land without GCS intervention.  Flag not set
                        # when plane is to loiter at Rally point until
                        # commanded to land.
enums['RALLY_FLAGS'][2] = EnumEntry('LAND_IMMEDIATELY', '''Flag set when plane is to immediately descend to break altitude and land without GCS intervention.  Flag not set when plane is to loiter at Rally point until commanded to land.''')
RALLY_FLAGS_ENUM_END = 3 # 
enums['RALLY_FLAGS'][3] = EnumEntry('RALLY_FLAGS_ENUM_END', '''''')

# PARACHUTE_ACTION
enums['PARACHUTE_ACTION'] = {}
PARACHUTE_DISABLE = 0 # Disable parachute release
enums['PARACHUTE_ACTION'][0] = EnumEntry('PARACHUTE_DISABLE', '''Disable parachute release''')
PARACHUTE_ENABLE = 1 # Enable parachute release
enums['PARACHUTE_ACTION'][1] = EnumEntry('PARACHUTE_ENABLE', '''Enable parachute release''')
PARACHUTE_RELEASE = 2 # Release parachute
enums['PARACHUTE_ACTION'][2] = EnumEntry('PARACHUTE_RELEASE', '''Release parachute''')
PARACHUTE_ACTION_ENUM_END = 3 # 
enums['PARACHUTE_ACTION'][3] = EnumEntry('PARACHUTE_ACTION_ENUM_END', '''''')

# MOTOR_TEST_THROTTLE_TYPE
enums['MOTOR_TEST_THROTTLE_TYPE'] = {}
MOTOR_TEST_THROTTLE_PERCENT = 0 # throttle as a percentage from 0 ~ 100
enums['MOTOR_TEST_THROTTLE_TYPE'][0] = EnumEntry('MOTOR_TEST_THROTTLE_PERCENT', '''throttle as a percentage from 0 ~ 100''')
MOTOR_TEST_THROTTLE_PWM = 1 # throttle as an absolute PWM value (normally in range of 1000~2000)
enums['MOTOR_TEST_THROTTLE_TYPE'][1] = EnumEntry('MOTOR_TEST_THROTTLE_PWM', '''throttle as an absolute PWM value (normally in range of 1000~2000)''')
MOTOR_TEST_THROTTLE_PILOT = 2 # throttle pass-through from pilot's transmitter
enums['MOTOR_TEST_THROTTLE_TYPE'][2] = EnumEntry('MOTOR_TEST_THROTTLE_PILOT', '''throttle pass-through from pilot's transmitter''')
MOTOR_TEST_THROTTLE_TYPE_ENUM_END = 3 # 
enums['MOTOR_TEST_THROTTLE_TYPE'][3] = EnumEntry('MOTOR_TEST_THROTTLE_TYPE_ENUM_END', '''''')

# GRIPPER_ACTIONS
enums['GRIPPER_ACTIONS'] = {}
GRIPPER_ACTION_RELEASE = 0 # gripper release of cargo
enums['GRIPPER_ACTIONS'][0] = EnumEntry('GRIPPER_ACTION_RELEASE', '''gripper release of cargo''')
GRIPPER_ACTION_GRAB = 1 # gripper grabs onto cargo
enums['GRIPPER_ACTIONS'][1] = EnumEntry('GRIPPER_ACTION_GRAB', '''gripper grabs onto cargo''')
GRIPPER_ACTIONS_ENUM_END = 2 # 
enums['GRIPPER_ACTIONS'][2] = EnumEntry('GRIPPER_ACTIONS_ENUM_END', '''''')

# CAMERA_STATUS_TYPES
enums['CAMERA_STATUS_TYPES'] = {}
CAMERA_STATUS_TYPE_HEARTBEAT = 0 # Camera heartbeat, announce camera component ID at 1hz
enums['CAMERA_STATUS_TYPES'][0] = EnumEntry('CAMERA_STATUS_TYPE_HEARTBEAT', '''Camera heartbeat, announce camera component ID at 1hz''')
CAMERA_STATUS_TYPE_TRIGGER = 1 # Camera image triggered
enums['CAMERA_STATUS_TYPES'][1] = EnumEntry('CAMERA_STATUS_TYPE_TRIGGER', '''Camera image triggered''')
CAMERA_STATUS_TYPE_DISCONNECT = 2 # Camera connection lost
enums['CAMERA_STATUS_TYPES'][2] = EnumEntry('CAMERA_STATUS_TYPE_DISCONNECT', '''Camera connection lost''')
CAMERA_STATUS_TYPE_ERROR = 3 # Camera unknown error
enums['CAMERA_STATUS_TYPES'][3] = EnumEntry('CAMERA_STATUS_TYPE_ERROR', '''Camera unknown error''')
CAMERA_STATUS_TYPE_LOWBATT = 4 # Camera battery low. Parameter p1 shows reported voltage
enums['CAMERA_STATUS_TYPES'][4] = EnumEntry('CAMERA_STATUS_TYPE_LOWBATT', '''Camera battery low. Parameter p1 shows reported voltage''')
CAMERA_STATUS_TYPE_LOWSTORE = 5 # Camera storage low. Parameter p1 shows reported shots remaining
enums['CAMERA_STATUS_TYPES'][5] = EnumEntry('CAMERA_STATUS_TYPE_LOWSTORE', '''Camera storage low. Parameter p1 shows reported shots remaining''')
CAMERA_STATUS_TYPE_LOWSTOREV = 6 # Camera storage low. Parameter p1 shows reported video minutes
                        # remaining
enums['CAMERA_STATUS_TYPES'][6] = EnumEntry('CAMERA_STATUS_TYPE_LOWSTOREV', '''Camera storage low. Parameter p1 shows reported video minutes remaining''')
CAMERA_STATUS_TYPES_ENUM_END = 7 # 
enums['CAMERA_STATUS_TYPES'][7] = EnumEntry('CAMERA_STATUS_TYPES_ENUM_END', '''''')

# CAMERA_FEEDBACK_FLAGS
enums['CAMERA_FEEDBACK_FLAGS'] = {}
VIDEO = 1 # Shooting video, not stills
enums['CAMERA_FEEDBACK_FLAGS'][1] = EnumEntry('VIDEO', '''Shooting video, not stills''')
BADEXPOSURE = 2 # Unable to achieve requested exposure (e.g. shutter speed too low)
enums['CAMERA_FEEDBACK_FLAGS'][2] = EnumEntry('BADEXPOSURE', '''Unable to achieve requested exposure (e.g. shutter speed too low)''')
CLOSEDLOOP = 3 # Closed loop feedback from camera, we know for sure it has successfully
                        # taken a picture
enums['CAMERA_FEEDBACK_FLAGS'][3] = EnumEntry('CLOSEDLOOP', '''Closed loop feedback from camera, we know for sure it has successfully taken a picture''')
OPENLOOP = 4 # Open loop camera, an image trigger has been requested but we can't
                        # know for sure it has successfully taken a
                        # picture
enums['CAMERA_FEEDBACK_FLAGS'][4] = EnumEntry('OPENLOOP', '''Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken a picture''')
CAMERA_FEEDBACK_FLAGS_ENUM_END = 5 # 
enums['CAMERA_FEEDBACK_FLAGS'][5] = EnumEntry('CAMERA_FEEDBACK_FLAGS_ENUM_END', '''''')

# MAV_MODE_GIMBAL
enums['MAV_MODE_GIMBAL'] = {}
MAV_MODE_GIMBAL_UNINITIALIZED = 0 # Gimbal is powered on but has not started initializing yet
enums['MAV_MODE_GIMBAL'][0] = EnumEntry('MAV_MODE_GIMBAL_UNINITIALIZED', '''Gimbal is powered on but has not started initializing yet''')
MAV_MODE_GIMBAL_CALIBRATING_PITCH = 1 # Gimbal is currently running calibration on the pitch axis
enums['MAV_MODE_GIMBAL'][1] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_PITCH', '''Gimbal is currently running calibration on the pitch axis''')
MAV_MODE_GIMBAL_CALIBRATING_ROLL = 2 # Gimbal is currently running calibration on the roll axis
enums['MAV_MODE_GIMBAL'][2] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_ROLL', '''Gimbal is currently running calibration on the roll axis''')
MAV_MODE_GIMBAL_CALIBRATING_YAW = 3 # Gimbal is currently running calibration on the yaw axis
enums['MAV_MODE_GIMBAL'][3] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_YAW', '''Gimbal is currently running calibration on the yaw axis''')
MAV_MODE_GIMBAL_INITIALIZED = 4 # Gimbal has finished calibrating and initializing, but is relaxed
                        # pending reception of first rate command from
                        # copter
enums['MAV_MODE_GIMBAL'][4] = EnumEntry('MAV_MODE_GIMBAL_INITIALIZED', '''Gimbal has finished calibrating and initializing, but is relaxed pending reception of first rate command from copter''')
MAV_MODE_GIMBAL_ACTIVE = 5 # Gimbal is actively stabilizing
enums['MAV_MODE_GIMBAL'][5] = EnumEntry('MAV_MODE_GIMBAL_ACTIVE', '''Gimbal is actively stabilizing''')
MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT = 6 # Gimbal is relaxed because it missed more than 10 expected rate command
                        # messages in a row.  Gimbal will move back to
                        # active mode when it receives a new rate
                        # command
enums['MAV_MODE_GIMBAL'][6] = EnumEntry('MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT', '''Gimbal is relaxed because it missed more than 10 expected rate command messages in a row.  Gimbal will move back to active mode when it receives a new rate command''')
MAV_MODE_GIMBAL_ENUM_END = 7 # 
enums['MAV_MODE_GIMBAL'][7] = EnumEntry('MAV_MODE_GIMBAL_ENUM_END', '''''')

# GIMBAL_AXIS
enums['GIMBAL_AXIS'] = {}
GIMBAL_AXIS_YAW = 0 # Gimbal yaw axis
enums['GIMBAL_AXIS'][0] = EnumEntry('GIMBAL_AXIS_YAW', '''Gimbal yaw axis''')
GIMBAL_AXIS_PITCH = 1 # Gimbal pitch axis
enums['GIMBAL_AXIS'][1] = EnumEntry('GIMBAL_AXIS_PITCH', '''Gimbal pitch axis''')
GIMBAL_AXIS_ROLL = 2 # Gimbal roll axis
enums['GIMBAL_AXIS'][2] = EnumEntry('GIMBAL_AXIS_ROLL', '''Gimbal roll axis''')
GIMBAL_AXIS_ENUM_END = 3 # 
enums['GIMBAL_AXIS'][3] = EnumEntry('GIMBAL_AXIS_ENUM_END', '''''')

# GIMBAL_AXIS_CALIBRATION_STATUS
enums['GIMBAL_AXIS_CALIBRATION_STATUS'] = {}
GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS = 0 # Axis calibration is in progress
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][0] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS', '''Axis calibration is in progress''')
GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED = 1 # Axis calibration succeeded
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][1] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED', '''Axis calibration succeeded''')
GIMBAL_AXIS_CALIBRATION_STATUS_FAILED = 2 # Axis calibration failed
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][2] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_FAILED', '''Axis calibration failed''')
GIMBAL_AXIS_CALIBRATION_STATUS_ENUM_END = 3 # 
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][3] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_ENUM_END', '''''')

# FACTORY_TEST
enums['FACTORY_TEST'] = {}
FACTORY_TEST_AXIS_RANGE_LIMITS = 0 # Tests to make sure each axis can move to its mechanical limits
enums['FACTORY_TEST'][0] = EnumEntry('FACTORY_TEST_AXIS_RANGE_LIMITS', '''Tests to make sure each axis can move to its mechanical limits''')
FACTORY_TEST_ENUM_END = 1 # 
enums['FACTORY_TEST'][1] = EnumEntry('FACTORY_TEST_ENUM_END', '''''')

# GOPRO_CMD_RESULT
enums['GOPRO_CMD_RESULT'] = {}
GOPRO_CMD_RESULT_UNKNOWN = 0 # The result of the command is unknown
enums['GOPRO_CMD_RESULT'][0] = EnumEntry('GOPRO_CMD_RESULT_UNKNOWN', '''The result of the command is unknown''')
GOPRO_CMD_RESULT_SUCCESSFUL = 1 # The command was successfully sent, and a response was successfully
                        # received
enums['GOPRO_CMD_RESULT'][1] = EnumEntry('GOPRO_CMD_RESULT_SUCCESSFUL', '''The command was successfully sent, and a response was successfully received''')
GOPRO_CMD_RESULT_SEND_CMD_START_TIMEOUT = 2 # Timed out waiting for the GoPro to acknowledge our request to send a
                        # command
enums['GOPRO_CMD_RESULT'][2] = EnumEntry('GOPRO_CMD_RESULT_SEND_CMD_START_TIMEOUT', '''Timed out waiting for the GoPro to acknowledge our request to send a command''')
GOPRO_CMD_RESULT_SEND_CMD_COMPLETE_TIMEOUT = 3 # Timed out waiting for the GoPro to read the command
enums['GOPRO_CMD_RESULT'][3] = EnumEntry('GOPRO_CMD_RESULT_SEND_CMD_COMPLETE_TIMEOUT', '''Timed out waiting for the GoPro to read the command''')
GOPRO_CMD_RESULT_GET_RESPONSE_START_TIMEOUT = 4 # Timed out waiting for the GoPro to begin transmitting a response to
                        # the command
enums['GOPRO_CMD_RESULT'][4] = EnumEntry('GOPRO_CMD_RESULT_GET_RESPONSE_START_TIMEOUT', '''Timed out waiting for the GoPro to begin transmitting a response to the command''')
GOPRO_CMD_RESULT_GET_RESPONSE_COMPLETE_TIMEOUT = 5 # Timed out waiting for the GoPro to finish transmitting a response to
                        # the command
enums['GOPRO_CMD_RESULT'][5] = EnumEntry('GOPRO_CMD_RESULT_GET_RESPONSE_COMPLETE_TIMEOUT', '''Timed out waiting for the GoPro to finish transmitting a response to the command''')
GOPRO_CMD_RESULT_GET_CMD_COMPLETE_TIMEOUT = 6 # Timed out waiting for the GoPro to finish transmitting its own command
enums['GOPRO_CMD_RESULT'][6] = EnumEntry('GOPRO_CMD_RESULT_GET_CMD_COMPLETE_TIMEOUT', '''Timed out waiting for the GoPro to finish transmitting its own command''')
GOPRO_CMD_RESULT_SEND_RESPONSE_START_TIMEOUT = 7 # Timed out waiting for the GoPro to start reading a response to its own
                        # command
enums['GOPRO_CMD_RESULT'][7] = EnumEntry('GOPRO_CMD_RESULT_SEND_RESPONSE_START_TIMEOUT', '''Timed out waiting for the GoPro to start reading a response to its own command''')
GOPRO_CMD_RESULT_SEND_RESPONSE_COMPLETE_TIMEOUT = 8 # Timed out waiting for the GoPro to finish reading a response to its
                        # own command
enums['GOPRO_CMD_RESULT'][8] = EnumEntry('GOPRO_CMD_RESULT_SEND_RESPONSE_COMPLETE_TIMEOUT', '''Timed out waiting for the GoPro to finish reading a response to its own command''')
GOPRO_CMD_RESULT_PREEMPTED = 9 # Command to the GoPro was preempted by the GoPro sending its own
                        # command
enums['GOPRO_CMD_RESULT'][9] = EnumEntry('GOPRO_CMD_RESULT_PREEMPTED', '''Command to the GoPro was preempted by the GoPro sending its own command''')
GOPRO_CMD_RECEIVED_DATA_OVERFLOW = 10 # More data than expected received in response to the command
enums['GOPRO_CMD_RESULT'][10] = EnumEntry('GOPRO_CMD_RECEIVED_DATA_OVERFLOW', '''More data than expected received in response to the command''')
GOPRO_CMD_RECEIVED_DATA_UNDERFLOW = 11 # Less data than expected received in response to the command
enums['GOPRO_CMD_RESULT'][11] = EnumEntry('GOPRO_CMD_RECEIVED_DATA_UNDERFLOW', '''Less data than expected received in response to the command''')
GOPRO_CMD_RESULT_ENUM_END = 12 # 
enums['GOPRO_CMD_RESULT'][12] = EnumEntry('GOPRO_CMD_RESULT_ENUM_END', '''''')

# LED_CONTROL_PATTERN
enums['LED_CONTROL_PATTERN'] = {}
LED_CONTROL_PATTERN_OFF = 0 # LED patterns off (return control to regular vehicle control)
enums['LED_CONTROL_PATTERN'][0] = EnumEntry('LED_CONTROL_PATTERN_OFF', '''LED patterns off (return control to regular vehicle control)''')
LED_CONTROL_PATTERN_FIRMWAREUPDATE = 1 # LEDs show pattern during firmware update
enums['LED_CONTROL_PATTERN'][1] = EnumEntry('LED_CONTROL_PATTERN_FIRMWAREUPDATE', '''LEDs show pattern during firmware update''')
LED_CONTROL_PATTERN_CUSTOM = 255 # Custom Pattern using custom bytes fields
enums['LED_CONTROL_PATTERN'][255] = EnumEntry('LED_CONTROL_PATTERN_CUSTOM', '''Custom Pattern using custom bytes fields''')
LED_CONTROL_PATTERN_ENUM_END = 256 # 
enums['LED_CONTROL_PATTERN'][256] = EnumEntry('LED_CONTROL_PATTERN_ENUM_END', '''''')

# EKF_STATUS_FLAGS
enums['EKF_STATUS_FLAGS'] = {}
EKF_ATTITUDE = 1 # set if EKF's attitude estimate is good
enums['EKF_STATUS_FLAGS'][1] = EnumEntry('EKF_ATTITUDE', '''set if EKF's attitude estimate is good''')
EKF_VELOCITY_HORIZ = 2 # set if EKF's horizontal velocity estimate is good
enums['EKF_STATUS_FLAGS'][2] = EnumEntry('EKF_VELOCITY_HORIZ', '''set if EKF's horizontal velocity estimate is good''')
EKF_VELOCITY_VERT = 4 # set if EKF's vertical velocity estimate is good
enums['EKF_STATUS_FLAGS'][4] = EnumEntry('EKF_VELOCITY_VERT', '''set if EKF's vertical velocity estimate is good''')
EKF_POS_HORIZ_REL = 8 # set if EKF's horizontal position (relative) estimate is good
enums['EKF_STATUS_FLAGS'][8] = EnumEntry('EKF_POS_HORIZ_REL', '''set if EKF's horizontal position (relative) estimate is good''')
EKF_POS_HORIZ_ABS = 16 # set if EKF's horizontal position (absolute) estimate is good
enums['EKF_STATUS_FLAGS'][16] = EnumEntry('EKF_POS_HORIZ_ABS', '''set if EKF's horizontal position (absolute) estimate is good''')
EKF_POS_VERT_ABS = 32 # set if EKF's vertical position (absolute) estimate is good
enums['EKF_STATUS_FLAGS'][32] = EnumEntry('EKF_POS_VERT_ABS', '''set if EKF's vertical position (absolute) estimate is good''')
EKF_POS_VERT_AGL = 64 # set if EKF's vertical position (above ground) estimate is good
enums['EKF_STATUS_FLAGS'][64] = EnumEntry('EKF_POS_VERT_AGL', '''set if EKF's vertical position (above ground) estimate is good''')
EKF_CONST_POS_MODE = 128 # EKF is in constant position mode and does not know it's absolute or
                        # relative position
enums['EKF_STATUS_FLAGS'][128] = EnumEntry('EKF_CONST_POS_MODE', '''EKF is in constant position mode and does not know it's absolute or relative position''')
EKF_PRED_POS_HORIZ_REL = 256 # set if EKF's predicted horizontal position (relative) estimate is good
enums['EKF_STATUS_FLAGS'][256] = EnumEntry('EKF_PRED_POS_HORIZ_REL', '''set if EKF's predicted horizontal position (relative) estimate is good''')
EKF_PRED_POS_HORIZ_ABS = 512 # set if EKF's predicted horizontal position (absolute) estimate is good
enums['EKF_STATUS_FLAGS'][512] = EnumEntry('EKF_PRED_POS_HORIZ_ABS', '''set if EKF's predicted horizontal position (absolute) estimate is good''')
EKF_STATUS_FLAGS_ENUM_END = 513 # 
enums['EKF_STATUS_FLAGS'][513] = EnumEntry('EKF_STATUS_FLAGS_ENUM_END', '''''')

# MAG_CAL_STATUS
enums['MAG_CAL_STATUS'] = {}
MAG_CAL_NOT_STARTED = 0 # 
enums['MAG_CAL_STATUS'][0] = EnumEntry('MAG_CAL_NOT_STARTED', '''''')
MAG_CAL_WAITING_TO_START = 1 # 
enums['MAG_CAL_STATUS'][1] = EnumEntry('MAG_CAL_WAITING_TO_START', '''''')
MAG_CAL_RUNNING_STEP_ONE = 2 # 
enums['MAG_CAL_STATUS'][2] = EnumEntry('MAG_CAL_RUNNING_STEP_ONE', '''''')
MAG_CAL_RUNNING_STEP_TWO = 3 # 
enums['MAG_CAL_STATUS'][3] = EnumEntry('MAG_CAL_RUNNING_STEP_TWO', '''''')
MAG_CAL_SUCCESS = 4 # 
enums['MAG_CAL_STATUS'][4] = EnumEntry('MAG_CAL_SUCCESS', '''''')
MAG_CAL_FAILED = 5 # 
enums['MAG_CAL_STATUS'][5] = EnumEntry('MAG_CAL_FAILED', '''''')
MAG_CAL_STATUS_ENUM_END = 6 # 
enums['MAG_CAL_STATUS'][6] = EnumEntry('MAG_CAL_STATUS_ENUM_END', '''''')

# PID_TUNING_AXIS
enums['PID_TUNING_AXIS'] = {}
PID_TUNING_ROLL = 1 # 
enums['PID_TUNING_AXIS'][1] = EnumEntry('PID_TUNING_ROLL', '''''')
PID_TUNING_PITCH = 2 # 
enums['PID_TUNING_AXIS'][2] = EnumEntry('PID_TUNING_PITCH', '''''')
PID_TUNING_YAW = 3 # 
enums['PID_TUNING_AXIS'][3] = EnumEntry('PID_TUNING_YAW', '''''')
PID_TUNING_AXIS_ENUM_END = 4 # 
enums['PID_TUNING_AXIS'][4] = EnumEntry('PID_TUNING_AXIS_ENUM_END', '''''')

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_TUNED_FREQUENCY = 187
MAVLINK_MSG_ID_PHASE_OFFSET = 188
MAVLINK_MSG_ID_SENSOR_OFFSETS = 150
MAVLINK_MSG_ID_SET_MAG_OFFSETS = 151
MAVLINK_MSG_ID_MEMINFO = 152
MAVLINK_MSG_ID_AP_ADC = 153
MAVLINK_MSG_ID_DIGICAM_CONFIGURE = 154
MAVLINK_MSG_ID_DIGICAM_CONTROL = 155
MAVLINK_MSG_ID_MOUNT_CONFIGURE = 156
MAVLINK_MSG_ID_MOUNT_CONTROL = 157
MAVLINK_MSG_ID_MOUNT_STATUS = 158
MAVLINK_MSG_ID_FENCE_POINT = 160
MAVLINK_MSG_ID_FENCE_FETCH_POINT = 161
MAVLINK_MSG_ID_FENCE_STATUS = 162
MAVLINK_MSG_ID_AHRS = 163
MAVLINK_MSG_ID_SIMSTATE = 164
MAVLINK_MSG_ID_HWSTATUS = 165
MAVLINK_MSG_ID_RADIO = 166
MAVLINK_MSG_ID_LIMITS_STATUS = 167
MAVLINK_MSG_ID_WIND = 168
MAVLINK_MSG_ID_DATA16 = 169
MAVLINK_MSG_ID_DATA32 = 170
MAVLINK_MSG_ID_DATA64 = 171
MAVLINK_MSG_ID_DATA96 = 172
MAVLINK_MSG_ID_RANGEFINDER = 173
MAVLINK_MSG_ID_AIRSPEED_AUTOCAL = 174
MAVLINK_MSG_ID_RALLY_POINT = 175
MAVLINK_MSG_ID_RALLY_FETCH_POINT = 176
MAVLINK_MSG_ID_COMPASSMOT_STATUS = 177
MAVLINK_MSG_ID_AHRS2 = 178
MAVLINK_MSG_ID_CAMERA_STATUS = 179
MAVLINK_MSG_ID_CAMERA_FEEDBACK = 180
MAVLINK_MSG_ID_BATTERY2 = 181
MAVLINK_MSG_ID_AHRS3 = 182
MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST = 183
MAVLINK_MSG_ID_LED_CONTROL = 186
MAVLINK_MSG_ID_MAG_CAL_PROGRESS = 191
MAVLINK_MSG_ID_MAG_CAL_REPORT = 192
MAVLINK_MSG_ID_EKF_STATUS_REPORT = 193
MAVLINK_MSG_ID_PID_TUNING = 194
MAVLINK_MSG_ID_GIMBAL_REPORT = 200
MAVLINK_MSG_ID_GIMBAL_CONTROL = 201
MAVLINK_MSG_ID_GIMBAL_RESET = 202
MAVLINK_MSG_ID_GIMBAL_AXIS_CALIBRATION_PROGRESS = 203
MAVLINK_MSG_ID_GIMBAL_SET_HOME_OFFSETS = 204
MAVLINK_MSG_ID_GIMBAL_HOME_OFFSET_CALIBRATION_RESULT = 205
MAVLINK_MSG_ID_GIMBAL_SET_FACTORY_PARAMETERS = 206
MAVLINK_MSG_ID_GIMBAL_FACTORY_PARAMETERS_LOADED = 207
MAVLINK_MSG_ID_GIMBAL_ERASE_FIRMWARE_AND_CONFIG = 208
MAVLINK_MSG_ID_GIMBAL_PERFORM_FACTORY_TESTS = 209
MAVLINK_MSG_ID_GIMBAL_REPORT_FACTORY_TESTS_PROGRESS = 210
MAVLINK_MSG_ID_GOPRO_POWER_ON = 215
MAVLINK_MSG_ID_GOPRO_POWER_OFF = 216
MAVLINK_MSG_ID_GOPRO_COMMAND = 217
MAVLINK_MSG_ID_GOPRO_RESPONSE = 218

class MAVLink_tuned_frequency_message(MAVLink_message):
        '''
        Control the tuned frequency of an SDR
        '''
        id = MAVLINK_MSG_ID_TUNED_FREQUENCY
        name = 'TUNED_FREQUENCY'
        fieldnames = ['tuned_freq']
        ordered_fieldnames = [ 'tuned_freq' ]
        format = '<f'
        native_format = bytearray('<f', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 155

        def __init__(self, tuned_freq):
                MAVLink_message.__init__(self, MAVLink_tuned_frequency_message.id, MAVLink_tuned_frequency_message.name)
                self._fieldnames = MAVLink_tuned_frequency_message.fieldnames
                self.tuned_freq = tuned_freq

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 155, struct.pack('<f', self.tuned_freq))

class MAVLink_phase_offset_message(MAVLink_message):
        '''
        The phase offset of a signal received by an SDR
        '''
        id = MAVLINK_MSG_ID_PHASE_OFFSET
        name = 'PHASE_OFFSET'
        fieldnames = ['phase_offset']
        ordered_fieldnames = [ 'phase_offset' ]
        format = '<H'
        native_format = bytearray('<H', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 35

        def __init__(self, phase_offset):
                MAVLink_message.__init__(self, MAVLink_phase_offset_message.id, MAVLink_phase_offset_message.name)
                self._fieldnames = MAVLink_phase_offset_message.fieldnames
                self.phase_offset = phase_offset

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 35, struct.pack('<H', self.phase_offset))

class MAVLink_sensor_offsets_message(MAVLink_message):
        '''
        Offsets and calibrations values for hardware         sensors.
        This makes it easier to debug the calibration process.
        '''
        id = MAVLINK_MSG_ID_SENSOR_OFFSETS
        name = 'SENSOR_OFFSETS'
        fieldnames = ['mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z', 'mag_declination', 'raw_press', 'raw_temp', 'gyro_cal_x', 'gyro_cal_y', 'gyro_cal_z', 'accel_cal_x', 'accel_cal_y', 'accel_cal_z']
        ordered_fieldnames = [ 'mag_declination', 'raw_press', 'raw_temp', 'gyro_cal_x', 'gyro_cal_y', 'gyro_cal_z', 'accel_cal_x', 'accel_cal_y', 'accel_cal_z', 'mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z' ]
        format = '<fiiffffffhhh'
        native_format = bytearray('<fiiffffffhhh', 'ascii')
        orders = [9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 134

        def __init__(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):
                MAVLink_message.__init__(self, MAVLink_sensor_offsets_message.id, MAVLink_sensor_offsets_message.name)
                self._fieldnames = MAVLink_sensor_offsets_message.fieldnames
                self.mag_ofs_x = mag_ofs_x
                self.mag_ofs_y = mag_ofs_y
                self.mag_ofs_z = mag_ofs_z
                self.mag_declination = mag_declination
                self.raw_press = raw_press
                self.raw_temp = raw_temp
                self.gyro_cal_x = gyro_cal_x
                self.gyro_cal_y = gyro_cal_y
                self.gyro_cal_z = gyro_cal_z
                self.accel_cal_x = accel_cal_x
                self.accel_cal_y = accel_cal_y
                self.accel_cal_z = accel_cal_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<fiiffffffhhh', self.mag_declination, self.raw_press, self.raw_temp, self.gyro_cal_x, self.gyro_cal_y, self.gyro_cal_z, self.accel_cal_x, self.accel_cal_y, self.accel_cal_z, self.mag_ofs_x, self.mag_ofs_y, self.mag_ofs_z))

class MAVLink_set_mag_offsets_message(MAVLink_message):
        '''
        Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead.
        Set the magnetometer offsets
        '''
        id = MAVLINK_MSG_ID_SET_MAG_OFFSETS
        name = 'SET_MAG_OFFSETS'
        fieldnames = ['target_system', 'target_component', 'mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z']
        ordered_fieldnames = [ 'mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z', 'target_system', 'target_component' ]
        format = '<hhhBB'
        native_format = bytearray('<hhhBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 219

        def __init__(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):
                MAVLink_message.__init__(self, MAVLink_set_mag_offsets_message.id, MAVLink_set_mag_offsets_message.name)
                self._fieldnames = MAVLink_set_mag_offsets_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.mag_ofs_x = mag_ofs_x
                self.mag_ofs_y = mag_ofs_y
                self.mag_ofs_z = mag_ofs_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 219, struct.pack('<hhhBB', self.mag_ofs_x, self.mag_ofs_y, self.mag_ofs_z, self.target_system, self.target_component))

class MAVLink_meminfo_message(MAVLink_message):
        '''
        state of APM memory
        '''
        id = MAVLINK_MSG_ID_MEMINFO
        name = 'MEMINFO'
        fieldnames = ['brkval', 'freemem']
        ordered_fieldnames = [ 'brkval', 'freemem' ]
        format = '<HH'
        native_format = bytearray('<HH', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 208

        def __init__(self, brkval, freemem):
                MAVLink_message.__init__(self, MAVLink_meminfo_message.id, MAVLink_meminfo_message.name)
                self._fieldnames = MAVLink_meminfo_message.fieldnames
                self.brkval = brkval
                self.freemem = freemem

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 208, struct.pack('<HH', self.brkval, self.freemem))

class MAVLink_ap_adc_message(MAVLink_message):
        '''
        raw ADC output
        '''
        id = MAVLINK_MSG_ID_AP_ADC
        name = 'AP_ADC'
        fieldnames = ['adc1', 'adc2', 'adc3', 'adc4', 'adc5', 'adc6']
        ordered_fieldnames = [ 'adc1', 'adc2', 'adc3', 'adc4', 'adc5', 'adc6' ]
        format = '<HHHHHH'
        native_format = bytearray('<HHHHHH', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 188

        def __init__(self, adc1, adc2, adc3, adc4, adc5, adc6):
                MAVLink_message.__init__(self, MAVLink_ap_adc_message.id, MAVLink_ap_adc_message.name)
                self._fieldnames = MAVLink_ap_adc_message.fieldnames
                self.adc1 = adc1
                self.adc2 = adc2
                self.adc3 = adc3
                self.adc4 = adc4
                self.adc5 = adc5
                self.adc6 = adc6

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 188, struct.pack('<HHHHHH', self.adc1, self.adc2, self.adc3, self.adc4, self.adc5, self.adc6))

class MAVLink_digicam_configure_message(MAVLink_message):
        '''
        Configure on-board Camera Control System.
        '''
        id = MAVLINK_MSG_ID_DIGICAM_CONFIGURE
        name = 'DIGICAM_CONFIGURE'
        fieldnames = ['target_system', 'target_component', 'mode', 'shutter_speed', 'aperture', 'iso', 'exposure_type', 'command_id', 'engine_cut_off', 'extra_param', 'extra_value']
        ordered_fieldnames = [ 'extra_value', 'shutter_speed', 'target_system', 'target_component', 'mode', 'aperture', 'iso', 'exposure_type', 'command_id', 'engine_cut_off', 'extra_param' ]
        format = '<fHBBBBBBBBB'
        native_format = bytearray('<fHBBBBBBBBB', 'ascii')
        orders = [2, 3, 4, 1, 5, 6, 7, 8, 9, 10, 0]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 84

        def __init__(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):
                MAVLink_message.__init__(self, MAVLink_digicam_configure_message.id, MAVLink_digicam_configure_message.name)
                self._fieldnames = MAVLink_digicam_configure_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.mode = mode
                self.shutter_speed = shutter_speed
                self.aperture = aperture
                self.iso = iso
                self.exposure_type = exposure_type
                self.command_id = command_id
                self.engine_cut_off = engine_cut_off
                self.extra_param = extra_param
                self.extra_value = extra_value

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 84, struct.pack('<fHBBBBBBBBB', self.extra_value, self.shutter_speed, self.target_system, self.target_component, self.mode, self.aperture, self.iso, self.exposure_type, self.command_id, self.engine_cut_off, self.extra_param))

class MAVLink_digicam_control_message(MAVLink_message):
        '''
        Control on-board Camera Control System to take shots.
        '''
        id = MAVLINK_MSG_ID_DIGICAM_CONTROL
        name = 'DIGICAM_CONTROL'
        fieldnames = ['target_system', 'target_component', 'session', 'zoom_pos', 'zoom_step', 'focus_lock', 'shot', 'command_id', 'extra_param', 'extra_value']
        ordered_fieldnames = [ 'extra_value', 'target_system', 'target_component', 'session', 'zoom_pos', 'zoom_step', 'focus_lock', 'shot', 'command_id', 'extra_param' ]
        format = '<fBBBBbBBBB'
        native_format = bytearray('<fBBBBbBBBB', 'ascii')
        orders = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 22

        def __init__(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):
                MAVLink_message.__init__(self, MAVLink_digicam_control_message.id, MAVLink_digicam_control_message.name)
                self._fieldnames = MAVLink_digicam_control_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.session = session
                self.zoom_pos = zoom_pos
                self.zoom_step = zoom_step
                self.focus_lock = focus_lock
                self.shot = shot
                self.command_id = command_id
                self.extra_param = extra_param
                self.extra_value = extra_value

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<fBBBBbBBBB', self.extra_value, self.target_system, self.target_component, self.session, self.zoom_pos, self.zoom_step, self.focus_lock, self.shot, self.command_id, self.extra_param))

class MAVLink_mount_configure_message(MAVLink_message):
        '''
        Message to configure a camera mount, directional antenna, etc.
        '''
        id = MAVLINK_MSG_ID_MOUNT_CONFIGURE
        name = 'MOUNT_CONFIGURE'
        fieldnames = ['target_system', 'target_component', 'mount_mode', 'stab_roll', 'stab_pitch', 'stab_yaw']
        ordered_fieldnames = [ 'target_system', 'target_component', 'mount_mode', 'stab_roll', 'stab_pitch', 'stab_yaw' ]
        format = '<BBBBBB'
        native_format = bytearray('<BBBBBB', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 19

        def __init__(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):
                MAVLink_message.__init__(self, MAVLink_mount_configure_message.id, MAVLink_mount_configure_message.name)
                self._fieldnames = MAVLink_mount_configure_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.mount_mode = mount_mode
                self.stab_roll = stab_roll
                self.stab_pitch = stab_pitch
                self.stab_yaw = stab_yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 19, struct.pack('<BBBBBB', self.target_system, self.target_component, self.mount_mode, self.stab_roll, self.stab_pitch, self.stab_yaw))

class MAVLink_mount_control_message(MAVLink_message):
        '''
        Message to control a camera mount, directional antenna, etc.
        '''
        id = MAVLINK_MSG_ID_MOUNT_CONTROL
        name = 'MOUNT_CONTROL'
        fieldnames = ['target_system', 'target_component', 'input_a', 'input_b', 'input_c', 'save_position']
        ordered_fieldnames = [ 'input_a', 'input_b', 'input_c', 'target_system', 'target_component', 'save_position' ]
        format = '<iiiBBB'
        native_format = bytearray('<iiiBBB', 'ascii')
        orders = [3, 4, 0, 1, 2, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 21

        def __init__(self, target_system, target_component, input_a, input_b, input_c, save_position):
                MAVLink_message.__init__(self, MAVLink_mount_control_message.id, MAVLink_mount_control_message.name)
                self._fieldnames = MAVLink_mount_control_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.input_a = input_a
                self.input_b = input_b
                self.input_c = input_c
                self.save_position = save_position

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<iiiBBB', self.input_a, self.input_b, self.input_c, self.target_system, self.target_component, self.save_position))

class MAVLink_mount_status_message(MAVLink_message):
        '''
        Message with some status from APM to GCS about camera or
        antenna mount
        '''
        id = MAVLINK_MSG_ID_MOUNT_STATUS
        name = 'MOUNT_STATUS'
        fieldnames = ['target_system', 'target_component', 'pointing_a', 'pointing_b', 'pointing_c']
        ordered_fieldnames = [ 'pointing_a', 'pointing_b', 'pointing_c', 'target_system', 'target_component' ]
        format = '<iiiBB'
        native_format = bytearray('<iiiBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 134

        def __init__(self, target_system, target_component, pointing_a, pointing_b, pointing_c):
                MAVLink_message.__init__(self, MAVLink_mount_status_message.id, MAVLink_mount_status_message.name)
                self._fieldnames = MAVLink_mount_status_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.pointing_a = pointing_a
                self.pointing_b = pointing_b
                self.pointing_c = pointing_c

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<iiiBB', self.pointing_a, self.pointing_b, self.pointing_c, self.target_system, self.target_component))

class MAVLink_fence_point_message(MAVLink_message):
        '''
        A fence point. Used to set a point when from               GCS
        -> MAV. Also used to return a point from MAV -> GCS
        '''
        id = MAVLINK_MSG_ID_FENCE_POINT
        name = 'FENCE_POINT'
        fieldnames = ['target_system', 'target_component', 'idx', 'count', 'lat', 'lng']
        ordered_fieldnames = [ 'lat', 'lng', 'target_system', 'target_component', 'idx', 'count' ]
        format = '<ffBBBB'
        native_format = bytearray('<ffBBBB', 'ascii')
        orders = [2, 3, 4, 5, 0, 1]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 78

        def __init__(self, target_system, target_component, idx, count, lat, lng):
                MAVLink_message.__init__(self, MAVLink_fence_point_message.id, MAVLink_fence_point_message.name)
                self._fieldnames = MAVLink_fence_point_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx
                self.count = count
                self.lat = lat
                self.lng = lng

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 78, struct.pack('<ffBBBB', self.lat, self.lng, self.target_system, self.target_component, self.idx, self.count))

class MAVLink_fence_fetch_point_message(MAVLink_message):
        '''
        Request a current fence point from MAV
        '''
        id = MAVLINK_MSG_ID_FENCE_FETCH_POINT
        name = 'FENCE_FETCH_POINT'
        fieldnames = ['target_system', 'target_component', 'idx']
        ordered_fieldnames = [ 'target_system', 'target_component', 'idx' ]
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 68

        def __init__(self, target_system, target_component, idx):
                MAVLink_message.__init__(self, MAVLink_fence_fetch_point_message.id, MAVLink_fence_fetch_point_message.name)
                self._fieldnames = MAVLink_fence_fetch_point_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 68, struct.pack('<BBB', self.target_system, self.target_component, self.idx))

class MAVLink_fence_status_message(MAVLink_message):
        '''
        Status of geo-fencing. Sent in extended             status
        stream when fencing enabled
        '''
        id = MAVLINK_MSG_ID_FENCE_STATUS
        name = 'FENCE_STATUS'
        fieldnames = ['breach_status', 'breach_count', 'breach_type', 'breach_time']
        ordered_fieldnames = [ 'breach_time', 'breach_count', 'breach_status', 'breach_type' ]
        format = '<IHBB'
        native_format = bytearray('<IHBB', 'ascii')
        orders = [2, 1, 3, 0]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 189

        def __init__(self, breach_status, breach_count, breach_type, breach_time):
                MAVLink_message.__init__(self, MAVLink_fence_status_message.id, MAVLink_fence_status_message.name)
                self._fieldnames = MAVLink_fence_status_message.fieldnames
                self.breach_status = breach_status
                self.breach_count = breach_count
                self.breach_type = breach_type
                self.breach_time = breach_time

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 189, struct.pack('<IHBB', self.breach_time, self.breach_count, self.breach_status, self.breach_type))

class MAVLink_ahrs_message(MAVLink_message):
        '''
        Status of DCM attitude estimator
        '''
        id = MAVLINK_MSG_ID_AHRS
        name = 'AHRS'
        fieldnames = ['omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw']
        ordered_fieldnames = [ 'omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw' ]
        format = '<fffffff'
        native_format = bytearray('<fffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 127

        def __init__(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                MAVLink_message.__init__(self, MAVLink_ahrs_message.id, MAVLink_ahrs_message.name)
                self._fieldnames = MAVLink_ahrs_message.fieldnames
                self.omegaIx = omegaIx
                self.omegaIy = omegaIy
                self.omegaIz = omegaIz
                self.accel_weight = accel_weight
                self.renorm_val = renorm_val
                self.error_rp = error_rp
                self.error_yaw = error_yaw

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 127, struct.pack('<fffffff', self.omegaIx, self.omegaIy, self.omegaIz, self.accel_weight, self.renorm_val, self.error_rp, self.error_yaw))

class MAVLink_simstate_message(MAVLink_message):
        '''
        Status of simulation environment, if used
        '''
        id = MAVLINK_MSG_ID_SIMSTATE
        name = 'SIMSTATE'
        fieldnames = ['roll', 'pitch', 'yaw', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'lat', 'lng']
        ordered_fieldnames = [ 'roll', 'pitch', 'yaw', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'lat', 'lng' ]
        format = '<fffffffffii'
        native_format = bytearray('<fffffffffii', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 154

        def __init__(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng):
                MAVLink_message.__init__(self, MAVLink_simstate_message.id, MAVLink_simstate_message.name)
                self._fieldnames = MAVLink_simstate_message.fieldnames
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.xacc = xacc
                self.yacc = yacc
                self.zacc = zacc
                self.xgyro = xgyro
                self.ygyro = ygyro
                self.zgyro = zgyro
                self.lat = lat
                self.lng = lng

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 154, struct.pack('<fffffffffii', self.roll, self.pitch, self.yaw, self.xacc, self.yacc, self.zacc, self.xgyro, self.ygyro, self.zgyro, self.lat, self.lng))

class MAVLink_hwstatus_message(MAVLink_message):
        '''
        Status of key hardware
        '''
        id = MAVLINK_MSG_ID_HWSTATUS
        name = 'HWSTATUS'
        fieldnames = ['Vcc', 'I2Cerr']
        ordered_fieldnames = [ 'Vcc', 'I2Cerr' ]
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 21

        def __init__(self, Vcc, I2Cerr):
                MAVLink_message.__init__(self, MAVLink_hwstatus_message.id, MAVLink_hwstatus_message.name)
                self._fieldnames = MAVLink_hwstatus_message.fieldnames
                self.Vcc = Vcc
                self.I2Cerr = I2Cerr

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<HB', self.Vcc, self.I2Cerr))

class MAVLink_radio_message(MAVLink_message):
        '''
        Status generated by radio
        '''
        id = MAVLINK_MSG_ID_RADIO
        name = 'RADIO'
        fieldnames = ['rssi', 'remrssi', 'txbuf', 'noise', 'remnoise', 'rxerrors', 'fixed']
        ordered_fieldnames = [ 'rxerrors', 'fixed', 'rssi', 'remrssi', 'txbuf', 'noise', 'remnoise' ]
        format = '<HHBBBBB'
        native_format = bytearray('<HHBBBBB', 'ascii')
        orders = [2, 3, 4, 5, 6, 0, 1]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 21

        def __init__(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed):
                MAVLink_message.__init__(self, MAVLink_radio_message.id, MAVLink_radio_message.name)
                self._fieldnames = MAVLink_radio_message.fieldnames
                self.rssi = rssi
                self.remrssi = remrssi
                self.txbuf = txbuf
                self.noise = noise
                self.remnoise = remnoise
                self.rxerrors = rxerrors
                self.fixed = fixed

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<HHBBBBB', self.rxerrors, self.fixed, self.rssi, self.remrssi, self.txbuf, self.noise, self.remnoise))

class MAVLink_limits_status_message(MAVLink_message):
        '''
        Status of AP_Limits. Sent in extended             status
        stream when AP_Limits is enabled
        '''
        id = MAVLINK_MSG_ID_LIMITS_STATUS
        name = 'LIMITS_STATUS'
        fieldnames = ['limits_state', 'last_trigger', 'last_action', 'last_recovery', 'last_clear', 'breach_count', 'mods_enabled', 'mods_required', 'mods_triggered']
        ordered_fieldnames = [ 'last_trigger', 'last_action', 'last_recovery', 'last_clear', 'breach_count', 'limits_state', 'mods_enabled', 'mods_required', 'mods_triggered' ]
        format = '<IIIIHBBBB'
        native_format = bytearray('<IIIIHBBBB', 'ascii')
        orders = [5, 0, 1, 2, 3, 4, 6, 7, 8]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 144

        def __init__(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):
                MAVLink_message.__init__(self, MAVLink_limits_status_message.id, MAVLink_limits_status_message.name)
                self._fieldnames = MAVLink_limits_status_message.fieldnames
                self.limits_state = limits_state
                self.last_trigger = last_trigger
                self.last_action = last_action
                self.last_recovery = last_recovery
                self.last_clear = last_clear
                self.breach_count = breach_count
                self.mods_enabled = mods_enabled
                self.mods_required = mods_required
                self.mods_triggered = mods_triggered

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 144, struct.pack('<IIIIHBBBB', self.last_trigger, self.last_action, self.last_recovery, self.last_clear, self.breach_count, self.limits_state, self.mods_enabled, self.mods_required, self.mods_triggered))

class MAVLink_wind_message(MAVLink_message):
        '''
        Wind estimation
        '''
        id = MAVLINK_MSG_ID_WIND
        name = 'WIND'
        fieldnames = ['direction', 'speed', 'speed_z']
        ordered_fieldnames = [ 'direction', 'speed', 'speed_z' ]
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 1

        def __init__(self, direction, speed, speed_z):
                MAVLink_message.__init__(self, MAVLink_wind_message.id, MAVLink_wind_message.name)
                self._fieldnames = MAVLink_wind_message.fieldnames
                self.direction = direction
                self.speed = speed
                self.speed_z = speed_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 1, struct.pack('<fff', self.direction, self.speed, self.speed_z))

class MAVLink_data16_message(MAVLink_message):
        '''
        Data packet, size 16
        '''
        id = MAVLINK_MSG_ID_DATA16
        name = 'DATA16'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = [ 'type', 'len', 'data' ]
        format = '<BB16B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 16]
        array_lengths = [0, 0, 16]
        crc_extra = 234

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data16_message.id, MAVLink_data16_message.name)
                self._fieldnames = MAVLink_data16_message.fieldnames
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 234, struct.pack('<BB16B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15]))

class MAVLink_data32_message(MAVLink_message):
        '''
        Data packet, size 32
        '''
        id = MAVLINK_MSG_ID_DATA32
        name = 'DATA32'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = [ 'type', 'len', 'data' ]
        format = '<BB32B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 32]
        array_lengths = [0, 0, 32]
        crc_extra = 73

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data32_message.id, MAVLink_data32_message.name)
                self._fieldnames = MAVLink_data32_message.fieldnames
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 73, struct.pack('<BB32B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31]))

class MAVLink_data64_message(MAVLink_message):
        '''
        Data packet, size 64
        '''
        id = MAVLINK_MSG_ID_DATA64
        name = 'DATA64'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = [ 'type', 'len', 'data' ]
        format = '<BB64B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 64]
        array_lengths = [0, 0, 64]
        crc_extra = 181

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data64_message.id, MAVLink_data64_message.name)
                self._fieldnames = MAVLink_data64_message.fieldnames
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 181, struct.pack('<BB64B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63]))

class MAVLink_data96_message(MAVLink_message):
        '''
        Data packet, size 96
        '''
        id = MAVLINK_MSG_ID_DATA96
        name = 'DATA96'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = [ 'type', 'len', 'data' ]
        format = '<BB96B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 96]
        array_lengths = [0, 0, 96]
        crc_extra = 22

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data96_message.id, MAVLink_data96_message.name)
                self._fieldnames = MAVLink_data96_message.fieldnames
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<BB96B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63], self.data[64], self.data[65], self.data[66], self.data[67], self.data[68], self.data[69], self.data[70], self.data[71], self.data[72], self.data[73], self.data[74], self.data[75], self.data[76], self.data[77], self.data[78], self.data[79], self.data[80], self.data[81], self.data[82], self.data[83], self.data[84], self.data[85], self.data[86], self.data[87], self.data[88], self.data[89], self.data[90], self.data[91], self.data[92], self.data[93], self.data[94], self.data[95]))

class MAVLink_rangefinder_message(MAVLink_message):
        '''
        Rangefinder reporting
        '''
        id = MAVLINK_MSG_ID_RANGEFINDER
        name = 'RANGEFINDER'
        fieldnames = ['distance', 'voltage']
        ordered_fieldnames = [ 'distance', 'voltage' ]
        format = '<ff'
        native_format = bytearray('<ff', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 83

        def __init__(self, distance, voltage):
                MAVLink_message.__init__(self, MAVLink_rangefinder_message.id, MAVLink_rangefinder_message.name)
                self._fieldnames = MAVLink_rangefinder_message.fieldnames
                self.distance = distance
                self.voltage = voltage

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 83, struct.pack('<ff', self.distance, self.voltage))

class MAVLink_airspeed_autocal_message(MAVLink_message):
        '''
        Airspeed auto-calibration
        '''
        id = MAVLINK_MSG_ID_AIRSPEED_AUTOCAL
        name = 'AIRSPEED_AUTOCAL'
        fieldnames = ['vx', 'vy', 'vz', 'diff_pressure', 'EAS2TAS', 'ratio', 'state_x', 'state_y', 'state_z', 'Pax', 'Pby', 'Pcz']
        ordered_fieldnames = [ 'vx', 'vy', 'vz', 'diff_pressure', 'EAS2TAS', 'ratio', 'state_x', 'state_y', 'state_z', 'Pax', 'Pby', 'Pcz' ]
        format = '<ffffffffffff'
        native_format = bytearray('<ffffffffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 167

        def __init__(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz):
                MAVLink_message.__init__(self, MAVLink_airspeed_autocal_message.id, MAVLink_airspeed_autocal_message.name)
                self._fieldnames = MAVLink_airspeed_autocal_message.fieldnames
                self.vx = vx
                self.vy = vy
                self.vz = vz
                self.diff_pressure = diff_pressure
                self.EAS2TAS = EAS2TAS
                self.ratio = ratio
                self.state_x = state_x
                self.state_y = state_y
                self.state_z = state_z
                self.Pax = Pax
                self.Pby = Pby
                self.Pcz = Pcz

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 167, struct.pack('<ffffffffffff', self.vx, self.vy, self.vz, self.diff_pressure, self.EAS2TAS, self.ratio, self.state_x, self.state_y, self.state_z, self.Pax, self.Pby, self.Pcz))

class MAVLink_rally_point_message(MAVLink_message):
        '''
        A rally point. Used to set a point when from GCS -> MAV. Also
        used to return a point from MAV -> GCS
        '''
        id = MAVLINK_MSG_ID_RALLY_POINT
        name = 'RALLY_POINT'
        fieldnames = ['target_system', 'target_component', 'idx', 'count', 'lat', 'lng', 'alt', 'break_alt', 'land_dir', 'flags']
        ordered_fieldnames = [ 'lat', 'lng', 'alt', 'break_alt', 'land_dir', 'target_system', 'target_component', 'idx', 'count', 'flags' ]
        format = '<iihhHBBBBB'
        native_format = bytearray('<iihhHBBBBB', 'ascii')
        orders = [5, 6, 7, 8, 0, 1, 2, 3, 4, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 138

        def __init__(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags):
                MAVLink_message.__init__(self, MAVLink_rally_point_message.id, MAVLink_rally_point_message.name)
                self._fieldnames = MAVLink_rally_point_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx
                self.count = count
                self.lat = lat
                self.lng = lng
                self.alt = alt
                self.break_alt = break_alt
                self.land_dir = land_dir
                self.flags = flags

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 138, struct.pack('<iihhHBBBBB', self.lat, self.lng, self.alt, self.break_alt, self.land_dir, self.target_system, self.target_component, self.idx, self.count, self.flags))

class MAVLink_rally_fetch_point_message(MAVLink_message):
        '''
        Request a current rally point from MAV. MAV should respond
        with a RALLY_POINT message. MAV should not respond if the
        request is invalid.
        '''
        id = MAVLINK_MSG_ID_RALLY_FETCH_POINT
        name = 'RALLY_FETCH_POINT'
        fieldnames = ['target_system', 'target_component', 'idx']
        ordered_fieldnames = [ 'target_system', 'target_component', 'idx' ]
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 234

        def __init__(self, target_system, target_component, idx):
                MAVLink_message.__init__(self, MAVLink_rally_fetch_point_message.id, MAVLink_rally_fetch_point_message.name)
                self._fieldnames = MAVLink_rally_fetch_point_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 234, struct.pack('<BBB', self.target_system, self.target_component, self.idx))

class MAVLink_compassmot_status_message(MAVLink_message):
        '''
        Status of compassmot calibration
        '''
        id = MAVLINK_MSG_ID_COMPASSMOT_STATUS
        name = 'COMPASSMOT_STATUS'
        fieldnames = ['throttle', 'current', 'interference', 'CompensationX', 'CompensationY', 'CompensationZ']
        ordered_fieldnames = [ 'current', 'CompensationX', 'CompensationY', 'CompensationZ', 'throttle', 'interference' ]
        format = '<ffffHH'
        native_format = bytearray('<ffffHH', 'ascii')
        orders = [4, 0, 5, 1, 2, 3]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 240

        def __init__(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ):
                MAVLink_message.__init__(self, MAVLink_compassmot_status_message.id, MAVLink_compassmot_status_message.name)
                self._fieldnames = MAVLink_compassmot_status_message.fieldnames
                self.throttle = throttle
                self.current = current
                self.interference = interference
                self.CompensationX = CompensationX
                self.CompensationY = CompensationY
                self.CompensationZ = CompensationZ

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 240, struct.pack('<ffffHH', self.current, self.CompensationX, self.CompensationY, self.CompensationZ, self.throttle, self.interference))

class MAVLink_ahrs2_message(MAVLink_message):
        '''
        Status of secondary AHRS filter if available
        '''
        id = MAVLINK_MSG_ID_AHRS2
        name = 'AHRS2'
        fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng']
        ordered_fieldnames = [ 'roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng' ]
        format = '<ffffii'
        native_format = bytearray('<ffffii', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 47

        def __init__(self, roll, pitch, yaw, altitude, lat, lng):
                MAVLink_message.__init__(self, MAVLink_ahrs2_message.id, MAVLink_ahrs2_message.name)
                self._fieldnames = MAVLink_ahrs2_message.fieldnames
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.altitude = altitude
                self.lat = lat
                self.lng = lng

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 47, struct.pack('<ffffii', self.roll, self.pitch, self.yaw, self.altitude, self.lat, self.lng))

class MAVLink_camera_status_message(MAVLink_message):
        '''
        Camera Event
        '''
        id = MAVLINK_MSG_ID_CAMERA_STATUS
        name = 'CAMERA_STATUS'
        fieldnames = ['time_usec', 'target_system', 'cam_idx', 'img_idx', 'event_id', 'p1', 'p2', 'p3', 'p4']
        ordered_fieldnames = [ 'time_usec', 'p1', 'p2', 'p3', 'p4', 'img_idx', 'target_system', 'cam_idx', 'event_id' ]
        format = '<QffffHBBB'
        native_format = bytearray('<QffffHBBB', 'ascii')
        orders = [0, 6, 7, 5, 8, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 189

        def __init__(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):
                MAVLink_message.__init__(self, MAVLink_camera_status_message.id, MAVLink_camera_status_message.name)
                self._fieldnames = MAVLink_camera_status_message.fieldnames
                self.time_usec = time_usec
                self.target_system = target_system
                self.cam_idx = cam_idx
                self.img_idx = img_idx
                self.event_id = event_id
                self.p1 = p1
                self.p2 = p2
                self.p3 = p3
                self.p4 = p4

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 189, struct.pack('<QffffHBBB', self.time_usec, self.p1, self.p2, self.p3, self.p4, self.img_idx, self.target_system, self.cam_idx, self.event_id))

class MAVLink_camera_feedback_message(MAVLink_message):
        '''
        Camera Capture Feedback
        '''
        id = MAVLINK_MSG_ID_CAMERA_FEEDBACK
        name = 'CAMERA_FEEDBACK'
        fieldnames = ['time_usec', 'target_system', 'cam_idx', 'img_idx', 'lat', 'lng', 'alt_msl', 'alt_rel', 'roll', 'pitch', 'yaw', 'foc_len', 'flags']
        ordered_fieldnames = [ 'time_usec', 'lat', 'lng', 'alt_msl', 'alt_rel', 'roll', 'pitch', 'yaw', 'foc_len', 'img_idx', 'target_system', 'cam_idx', 'flags' ]
        format = '<QiiffffffHBBB'
        native_format = bytearray('<QiiffffffHBBB', 'ascii')
        orders = [0, 10, 11, 9, 1, 2, 3, 4, 5, 6, 7, 8, 12]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 52

        def __init__(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):
                MAVLink_message.__init__(self, MAVLink_camera_feedback_message.id, MAVLink_camera_feedback_message.name)
                self._fieldnames = MAVLink_camera_feedback_message.fieldnames
                self.time_usec = time_usec
                self.target_system = target_system
                self.cam_idx = cam_idx
                self.img_idx = img_idx
                self.lat = lat
                self.lng = lng
                self.alt_msl = alt_msl
                self.alt_rel = alt_rel
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.foc_len = foc_len
                self.flags = flags

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 52, struct.pack('<QiiffffffHBBB', self.time_usec, self.lat, self.lng, self.alt_msl, self.alt_rel, self.roll, self.pitch, self.yaw, self.foc_len, self.img_idx, self.target_system, self.cam_idx, self.flags))

class MAVLink_battery2_message(MAVLink_message):
        '''
        2nd Battery status
        '''
        id = MAVLINK_MSG_ID_BATTERY2
        name = 'BATTERY2'
        fieldnames = ['voltage', 'current_battery']
        ordered_fieldnames = [ 'voltage', 'current_battery' ]
        format = '<Hh'
        native_format = bytearray('<Hh', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 174

        def __init__(self, voltage, current_battery):
                MAVLink_message.__init__(self, MAVLink_battery2_message.id, MAVLink_battery2_message.name)
                self._fieldnames = MAVLink_battery2_message.fieldnames
                self.voltage = voltage
                self.current_battery = current_battery

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 174, struct.pack('<Hh', self.voltage, self.current_battery))

class MAVLink_ahrs3_message(MAVLink_message):
        '''
        Status of third AHRS filter if available. This is for ANU
        research group (Ali and Sean)
        '''
        id = MAVLINK_MSG_ID_AHRS3
        name = 'AHRS3'
        fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng', 'v1', 'v2', 'v3', 'v4']
        ordered_fieldnames = [ 'roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng', 'v1', 'v2', 'v3', 'v4' ]
        format = '<ffffiiffff'
        native_format = bytearray('<ffffiiffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 229

        def __init__(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4):
                MAVLink_message.__init__(self, MAVLink_ahrs3_message.id, MAVLink_ahrs3_message.name)
                self._fieldnames = MAVLink_ahrs3_message.fieldnames
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.altitude = altitude
                self.lat = lat
                self.lng = lng
                self.v1 = v1
                self.v2 = v2
                self.v3 = v3
                self.v4 = v4

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 229, struct.pack('<ffffiiffff', self.roll, self.pitch, self.yaw, self.altitude, self.lat, self.lng, self.v1, self.v2, self.v3, self.v4))

class MAVLink_autopilot_version_request_message(MAVLink_message):
        '''
        Request the autopilot version from the system/component.
        '''
        id = MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST
        name = 'AUTOPILOT_VERSION_REQUEST'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 85

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_autopilot_version_request_message.id, MAVLink_autopilot_version_request_message.name)
                self._fieldnames = MAVLink_autopilot_version_request_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 85, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_led_control_message(MAVLink_message):
        '''
        Control vehicle LEDs
        '''
        id = MAVLINK_MSG_ID_LED_CONTROL
        name = 'LED_CONTROL'
        fieldnames = ['target_system', 'target_component', 'instance', 'pattern', 'custom_len', 'custom_bytes']
        ordered_fieldnames = [ 'target_system', 'target_component', 'instance', 'pattern', 'custom_len', 'custom_bytes' ]
        format = '<BBBBB24B'
        native_format = bytearray('<BBBBBB', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 24]
        array_lengths = [0, 0, 0, 0, 0, 24]
        crc_extra = 72

        def __init__(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):
                MAVLink_message.__init__(self, MAVLink_led_control_message.id, MAVLink_led_control_message.name)
                self._fieldnames = MAVLink_led_control_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.instance = instance
                self.pattern = pattern
                self.custom_len = custom_len
                self.custom_bytes = custom_bytes

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 72, struct.pack('<BBBBB24B', self.target_system, self.target_component, self.instance, self.pattern, self.custom_len, self.custom_bytes[0], self.custom_bytes[1], self.custom_bytes[2], self.custom_bytes[3], self.custom_bytes[4], self.custom_bytes[5], self.custom_bytes[6], self.custom_bytes[7], self.custom_bytes[8], self.custom_bytes[9], self.custom_bytes[10], self.custom_bytes[11], self.custom_bytes[12], self.custom_bytes[13], self.custom_bytes[14], self.custom_bytes[15], self.custom_bytes[16], self.custom_bytes[17], self.custom_bytes[18], self.custom_bytes[19], self.custom_bytes[20], self.custom_bytes[21], self.custom_bytes[22], self.custom_bytes[23]))

class MAVLink_mag_cal_progress_message(MAVLink_message):
        '''
        Reports progress of compass calibration.
        '''
        id = MAVLINK_MSG_ID_MAG_CAL_PROGRESS
        name = 'MAG_CAL_PROGRESS'
        fieldnames = ['compass_id', 'cal_mask', 'cal_status', 'attempt', 'completion_pct', 'completion_mask', 'direction_x', 'direction_y', 'direction_z']
        ordered_fieldnames = [ 'direction_x', 'direction_y', 'direction_z', 'compass_id', 'cal_mask', 'cal_status', 'attempt', 'completion_pct', 'completion_mask' ]
        format = '<fffBBBBB10B'
        native_format = bytearray('<fffBBBBBB', 'ascii')
        orders = [3, 4, 5, 6, 7, 8, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 10]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 10]
        crc_extra = 92

        def __init__(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):
                MAVLink_message.__init__(self, MAVLink_mag_cal_progress_message.id, MAVLink_mag_cal_progress_message.name)
                self._fieldnames = MAVLink_mag_cal_progress_message.fieldnames
                self.compass_id = compass_id
                self.cal_mask = cal_mask
                self.cal_status = cal_status
                self.attempt = attempt
                self.completion_pct = completion_pct
                self.completion_mask = completion_mask
                self.direction_x = direction_x
                self.direction_y = direction_y
                self.direction_z = direction_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 92, struct.pack('<fffBBBBB10B', self.direction_x, self.direction_y, self.direction_z, self.compass_id, self.cal_mask, self.cal_status, self.attempt, self.completion_pct, self.completion_mask[0], self.completion_mask[1], self.completion_mask[2], self.completion_mask[3], self.completion_mask[4], self.completion_mask[5], self.completion_mask[6], self.completion_mask[7], self.completion_mask[8], self.completion_mask[9]))

class MAVLink_mag_cal_report_message(MAVLink_message):
        '''
        Reports results of completed compass calibration. Sent until
        MAG_CAL_ACK received.
        '''
        id = MAVLINK_MSG_ID_MAG_CAL_REPORT
        name = 'MAG_CAL_REPORT'
        fieldnames = ['compass_id', 'cal_mask', 'cal_status', 'autosaved', 'fitness', 'ofs_x', 'ofs_y', 'ofs_z', 'diag_x', 'diag_y', 'diag_z', 'offdiag_x', 'offdiag_y', 'offdiag_z']
        ordered_fieldnames = [ 'fitness', 'ofs_x', 'ofs_y', 'ofs_z', 'diag_x', 'diag_y', 'diag_z', 'offdiag_x', 'offdiag_y', 'offdiag_z', 'compass_id', 'cal_mask', 'cal_status', 'autosaved' ]
        format = '<ffffffffffBBBB'
        native_format = bytearray('<ffffffffffBBBB', 'ascii')
        orders = [10, 11, 12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 36

        def __init__(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):
                MAVLink_message.__init__(self, MAVLink_mag_cal_report_message.id, MAVLink_mag_cal_report_message.name)
                self._fieldnames = MAVLink_mag_cal_report_message.fieldnames
                self.compass_id = compass_id
                self.cal_mask = cal_mask
                self.cal_status = cal_status
                self.autosaved = autosaved
                self.fitness = fitness
                self.ofs_x = ofs_x
                self.ofs_y = ofs_y
                self.ofs_z = ofs_z
                self.diag_x = diag_x
                self.diag_y = diag_y
                self.diag_z = diag_z
                self.offdiag_x = offdiag_x
                self.offdiag_y = offdiag_y
                self.offdiag_z = offdiag_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 36, struct.pack('<ffffffffffBBBB', self.fitness, self.ofs_x, self.ofs_y, self.ofs_z, self.diag_x, self.diag_y, self.diag_z, self.offdiag_x, self.offdiag_y, self.offdiag_z, self.compass_id, self.cal_mask, self.cal_status, self.autosaved))

class MAVLink_ekf_status_report_message(MAVLink_message):
        '''
        EKF Status message including flags and variances
        '''
        id = MAVLINK_MSG_ID_EKF_STATUS_REPORT
        name = 'EKF_STATUS_REPORT'
        fieldnames = ['flags', 'velocity_variance', 'pos_horiz_variance', 'pos_vert_variance', 'compass_variance', 'terrain_alt_variance']
        ordered_fieldnames = [ 'velocity_variance', 'pos_horiz_variance', 'pos_vert_variance', 'compass_variance', 'terrain_alt_variance', 'flags' ]
        format = '<fffffH'
        native_format = bytearray('<fffffH', 'ascii')
        orders = [5, 0, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 71

        def __init__(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance):
                MAVLink_message.__init__(self, MAVLink_ekf_status_report_message.id, MAVLink_ekf_status_report_message.name)
                self._fieldnames = MAVLink_ekf_status_report_message.fieldnames
                self.flags = flags
                self.velocity_variance = velocity_variance
                self.pos_horiz_variance = pos_horiz_variance
                self.pos_vert_variance = pos_vert_variance
                self.compass_variance = compass_variance
                self.terrain_alt_variance = terrain_alt_variance

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 71, struct.pack('<fffffH', self.velocity_variance, self.pos_horiz_variance, self.pos_vert_variance, self.compass_variance, self.terrain_alt_variance, self.flags))

class MAVLink_pid_tuning_message(MAVLink_message):
        '''
        PID tuning information
        '''
        id = MAVLINK_MSG_ID_PID_TUNING
        name = 'PID_TUNING'
        fieldnames = ['axis', 'desired', 'achieved', 'FF', 'P', 'I', 'D']
        ordered_fieldnames = [ 'desired', 'achieved', 'FF', 'P', 'I', 'D', 'axis' ]
        format = '<ffffffB'
        native_format = bytearray('<ffffffB', 'ascii')
        orders = [6, 0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 98

        def __init__(self, axis, desired, achieved, FF, P, I, D):
                MAVLink_message.__init__(self, MAVLink_pid_tuning_message.id, MAVLink_pid_tuning_message.name)
                self._fieldnames = MAVLink_pid_tuning_message.fieldnames
                self.axis = axis
                self.desired = desired
                self.achieved = achieved
                self.FF = FF
                self.P = P
                self.I = I
                self.D = D

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 98, struct.pack('<ffffffB', self.desired, self.achieved, self.FF, self.P, self.I, self.D, self.axis))

class MAVLink_gimbal_report_message(MAVLink_message):
        '''
        3 axis gimbal mesuraments
        '''
        id = MAVLINK_MSG_ID_GIMBAL_REPORT
        name = 'GIMBAL_REPORT'
        fieldnames = ['target_system', 'target_component', 'delta_time', 'delta_angle_x', 'delta_angle_y', 'delta_angle_z', 'delta_velocity_x', 'delta_velocity_y', 'delta_velocity_z', 'joint_roll', 'joint_el', 'joint_az']
        ordered_fieldnames = [ 'delta_time', 'delta_angle_x', 'delta_angle_y', 'delta_angle_z', 'delta_velocity_x', 'delta_velocity_y', 'delta_velocity_z', 'joint_roll', 'joint_el', 'joint_az', 'target_system', 'target_component' ]
        format = '<ffffffffffBB'
        native_format = bytearray('<ffffffffffBB', 'ascii')
        orders = [10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 134

        def __init__(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):
                MAVLink_message.__init__(self, MAVLink_gimbal_report_message.id, MAVLink_gimbal_report_message.name)
                self._fieldnames = MAVLink_gimbal_report_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.delta_time = delta_time
                self.delta_angle_x = delta_angle_x
                self.delta_angle_y = delta_angle_y
                self.delta_angle_z = delta_angle_z
                self.delta_velocity_x = delta_velocity_x
                self.delta_velocity_y = delta_velocity_y
                self.delta_velocity_z = delta_velocity_z
                self.joint_roll = joint_roll
                self.joint_el = joint_el
                self.joint_az = joint_az

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<ffffffffffBB', self.delta_time, self.delta_angle_x, self.delta_angle_y, self.delta_angle_z, self.delta_velocity_x, self.delta_velocity_y, self.delta_velocity_z, self.joint_roll, self.joint_el, self.joint_az, self.target_system, self.target_component))

class MAVLink_gimbal_control_message(MAVLink_message):
        '''
        Control message for rate gimbal
        '''
        id = MAVLINK_MSG_ID_GIMBAL_CONTROL
        name = 'GIMBAL_CONTROL'
        fieldnames = ['target_system', 'target_component', 'demanded_rate_x', 'demanded_rate_y', 'demanded_rate_z']
        ordered_fieldnames = [ 'demanded_rate_x', 'demanded_rate_y', 'demanded_rate_z', 'target_system', 'target_component' ]
        format = '<fffBB'
        native_format = bytearray('<fffBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 205

        def __init__(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):
                MAVLink_message.__init__(self, MAVLink_gimbal_control_message.id, MAVLink_gimbal_control_message.name)
                self._fieldnames = MAVLink_gimbal_control_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.demanded_rate_x = demanded_rate_x
                self.demanded_rate_y = demanded_rate_y
                self.demanded_rate_z = demanded_rate_z

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 205, struct.pack('<fffBB', self.demanded_rate_x, self.demanded_rate_y, self.demanded_rate_z, self.target_system, self.target_component))

class MAVLink_gimbal_reset_message(MAVLink_message):
        '''
        Causes the gimbal to reset and boot as if it was just powered
        on
        '''
        id = MAVLINK_MSG_ID_GIMBAL_RESET
        name = 'GIMBAL_RESET'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 94

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_gimbal_reset_message.id, MAVLink_gimbal_reset_message.name)
                self._fieldnames = MAVLink_gimbal_reset_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 94, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_gimbal_axis_calibration_progress_message(MAVLink_message):
        '''
        Reports progress and success or failure of gimbal axis
        calibration procedure
        '''
        id = MAVLINK_MSG_ID_GIMBAL_AXIS_CALIBRATION_PROGRESS
        name = 'GIMBAL_AXIS_CALIBRATION_PROGRESS'
        fieldnames = ['calibration_axis', 'calibration_progress', 'calibration_status']
        ordered_fieldnames = [ 'calibration_axis', 'calibration_progress', 'calibration_status' ]
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 128

        def __init__(self, calibration_axis, calibration_progress, calibration_status):
                MAVLink_message.__init__(self, MAVLink_gimbal_axis_calibration_progress_message.id, MAVLink_gimbal_axis_calibration_progress_message.name)
                self._fieldnames = MAVLink_gimbal_axis_calibration_progress_message.fieldnames
                self.calibration_axis = calibration_axis
                self.calibration_progress = calibration_progress
                self.calibration_status = calibration_status

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 128, struct.pack('<BBB', self.calibration_axis, self.calibration_progress, self.calibration_status))

class MAVLink_gimbal_set_home_offsets_message(MAVLink_message):
        '''
        Instructs the gimbal to set its current position as its new
        home position.  Will primarily be used for factory calibration
        '''
        id = MAVLINK_MSG_ID_GIMBAL_SET_HOME_OFFSETS
        name = 'GIMBAL_SET_HOME_OFFSETS'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 54

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_gimbal_set_home_offsets_message.id, MAVLink_gimbal_set_home_offsets_message.name)
                self._fieldnames = MAVLink_gimbal_set_home_offsets_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 54, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_gimbal_home_offset_calibration_result_message(MAVLink_message):
        '''
        Sent by the gimbal after it receives a SET_HOME_OFFSETS
        message to indicate the result of the home offset calibration
        '''
        id = MAVLINK_MSG_ID_GIMBAL_HOME_OFFSET_CALIBRATION_RESULT
        name = 'GIMBAL_HOME_OFFSET_CALIBRATION_RESULT'
        fieldnames = ['calibration_result']
        ordered_fieldnames = [ 'calibration_result' ]
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 63

        def __init__(self, calibration_result):
                MAVLink_message.__init__(self, MAVLink_gimbal_home_offset_calibration_result_message.id, MAVLink_gimbal_home_offset_calibration_result_message.name)
                self._fieldnames = MAVLink_gimbal_home_offset_calibration_result_message.fieldnames
                self.calibration_result = calibration_result

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 63, struct.pack('<B', self.calibration_result))

class MAVLink_gimbal_set_factory_parameters_message(MAVLink_message):
        '''
        Set factory configuration parameters (such as assembly date
        and time, and serial number).  This is only intended to be
        used             during manufacture, not by end users, so it
        is protected by a simple checksum of sorts (this won't stop
        anybody determined,             it's mostly just to keep the
        average user from trying to modify these values.  This will
        need to be revisited if that isn't             adequate.
        '''
        id = MAVLINK_MSG_ID_GIMBAL_SET_FACTORY_PARAMETERS
        name = 'GIMBAL_SET_FACTORY_PARAMETERS'
        fieldnames = ['target_system', 'target_component', 'magic_1', 'magic_2', 'magic_3', 'assembly_year', 'assembly_month', 'assembly_day', 'assembly_hour', 'assembly_minute', 'assembly_second', 'serial_number_pt_1', 'serial_number_pt_2', 'serial_number_pt_3']
        ordered_fieldnames = [ 'magic_1', 'magic_2', 'magic_3', 'serial_number_pt_1', 'serial_number_pt_2', 'serial_number_pt_3', 'assembly_year', 'target_system', 'target_component', 'assembly_month', 'assembly_day', 'assembly_hour', 'assembly_minute', 'assembly_second' ]
        format = '<IIIIIIHBBBBBBB'
        native_format = bytearray('<IIIIIIHBBBBBBB', 'ascii')
        orders = [7, 8, 0, 1, 2, 6, 9, 10, 11, 12, 13, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 112

        def __init__(self, target_system, target_component, magic_1, magic_2, magic_3, assembly_year, assembly_month, assembly_day, assembly_hour, assembly_minute, assembly_second, serial_number_pt_1, serial_number_pt_2, serial_number_pt_3):
                MAVLink_message.__init__(self, MAVLink_gimbal_set_factory_parameters_message.id, MAVLink_gimbal_set_factory_parameters_message.name)
                self._fieldnames = MAVLink_gimbal_set_factory_parameters_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.magic_1 = magic_1
                self.magic_2 = magic_2
                self.magic_3 = magic_3
                self.assembly_year = assembly_year
                self.assembly_month = assembly_month
                self.assembly_day = assembly_day
                self.assembly_hour = assembly_hour
                self.assembly_minute = assembly_minute
                self.assembly_second = assembly_second
                self.serial_number_pt_1 = serial_number_pt_1
                self.serial_number_pt_2 = serial_number_pt_2
                self.serial_number_pt_3 = serial_number_pt_3

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 112, struct.pack('<IIIIIIHBBBBBBB', self.magic_1, self.magic_2, self.magic_3, self.serial_number_pt_1, self.serial_number_pt_2, self.serial_number_pt_3, self.assembly_year, self.target_system, self.target_component, self.assembly_month, self.assembly_day, self.assembly_hour, self.assembly_minute, self.assembly_second))

class MAVLink_gimbal_factory_parameters_loaded_message(MAVLink_message):
        '''
        Sent by the gimbal after the factory parameters are
        successfully loaded, to inform the factory software that the
        load is complete
        '''
        id = MAVLINK_MSG_ID_GIMBAL_FACTORY_PARAMETERS_LOADED
        name = 'GIMBAL_FACTORY_PARAMETERS_LOADED'
        fieldnames = ['dummy']
        ordered_fieldnames = [ 'dummy' ]
        format = '<B'
        native_format = bytearray('<B', 'ascii')
        orders = [0]
        lengths = [1]
        array_lengths = [0]
        crc_extra = 201

        def __init__(self, dummy):
                MAVLink_message.__init__(self, MAVLink_gimbal_factory_parameters_loaded_message.id, MAVLink_gimbal_factory_parameters_loaded_message.name)
                self._fieldnames = MAVLink_gimbal_factory_parameters_loaded_message.fieldnames
                self.dummy = dummy

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 201, struct.pack('<B', self.dummy))

class MAVLink_gimbal_erase_firmware_and_config_message(MAVLink_message):
        '''
        Commands the gimbal to erase its firmware image and flash
        configuration, leaving only the bootloader.  The gimbal will
        then reboot into the bootloader,             ready for the
        load of a new application firmware image.  Erasing the flash
        configuration will cause the gimbal to re-perform axis
        calibration when a             new firmware image is loaded,
        and will cause all tuning parameters to return to their
        factory defaults.  WARNING: sending this command will render a
        gimbal inoperable until a new firmware image is loaded onto
        it.  For this reason, a particular "knock" value must be sent
        for the command to take effect.             Use this command
        at your own risk
        '''
        id = MAVLINK_MSG_ID_GIMBAL_ERASE_FIRMWARE_AND_CONFIG
        name = 'GIMBAL_ERASE_FIRMWARE_AND_CONFIG'
        fieldnames = ['target_system', 'target_component', 'knock']
        ordered_fieldnames = [ 'knock', 'target_system', 'target_component' ]
        format = '<IBB'
        native_format = bytearray('<IBB', 'ascii')
        orders = [1, 2, 0]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 221

        def __init__(self, target_system, target_component, knock):
                MAVLink_message.__init__(self, MAVLink_gimbal_erase_firmware_and_config_message.id, MAVLink_gimbal_erase_firmware_and_config_message.name)
                self._fieldnames = MAVLink_gimbal_erase_firmware_and_config_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.knock = knock

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 221, struct.pack('<IBB', self.knock, self.target_system, self.target_component))

class MAVLink_gimbal_perform_factory_tests_message(MAVLink_message):
        '''
        Command the gimbal to perform a series of factory tests.
        Should not be needed by end users
        '''
        id = MAVLINK_MSG_ID_GIMBAL_PERFORM_FACTORY_TESTS
        name = 'GIMBAL_PERFORM_FACTORY_TESTS'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 226

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_gimbal_perform_factory_tests_message.id, MAVLink_gimbal_perform_factory_tests_message.name)
                self._fieldnames = MAVLink_gimbal_perform_factory_tests_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 226, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_gimbal_report_factory_tests_progress_message(MAVLink_message):
        '''
        Reports the current status of a section of a running factory
        test
        '''
        id = MAVLINK_MSG_ID_GIMBAL_REPORT_FACTORY_TESTS_PROGRESS
        name = 'GIMBAL_REPORT_FACTORY_TESTS_PROGRESS'
        fieldnames = ['test', 'test_section', 'test_section_progress', 'test_status']
        ordered_fieldnames = [ 'test', 'test_section', 'test_section_progress', 'test_status' ]
        format = '<BBBB'
        native_format = bytearray('<BBBB', 'ascii')
        orders = [0, 1, 2, 3]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 238

        def __init__(self, test, test_section, test_section_progress, test_status):
                MAVLink_message.__init__(self, MAVLink_gimbal_report_factory_tests_progress_message.id, MAVLink_gimbal_report_factory_tests_progress_message.name)
                self._fieldnames = MAVLink_gimbal_report_factory_tests_progress_message.fieldnames
                self.test = test
                self.test_section = test_section
                self.test_section_progress = test_section_progress
                self.test_status = test_status

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 238, struct.pack('<BBBB', self.test, self.test_section, self.test_section_progress, self.test_status))

class MAVLink_gopro_power_on_message(MAVLink_message):
        '''
        Instruct a HeroBus attached GoPro to power on
        '''
        id = MAVLINK_MSG_ID_GOPRO_POWER_ON
        name = 'GOPRO_POWER_ON'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 241

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_gopro_power_on_message.id, MAVLink_gopro_power_on_message.name)
                self._fieldnames = MAVLink_gopro_power_on_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 241, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_gopro_power_off_message(MAVLink_message):
        '''
        Instruct a HeroBus attached GoPro to power off
        '''
        id = MAVLINK_MSG_ID_GOPRO_POWER_OFF
        name = 'GOPRO_POWER_OFF'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = [ 'target_system', 'target_component' ]
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 155

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_gopro_power_off_message.id, MAVLink_gopro_power_off_message.name)
                self._fieldnames = MAVLink_gopro_power_off_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 155, struct.pack('<BB', self.target_system, self.target_component))

class MAVLink_gopro_command_message(MAVLink_message):
        '''
        Send a command to a HeroBus attached GoPro.  Will generate a
        GOPRO_RESPONSE message with results of the command
        '''
        id = MAVLINK_MSG_ID_GOPRO_COMMAND
        name = 'GOPRO_COMMAND'
        fieldnames = ['target_system', 'target_component', 'gp_cmd_name_1', 'gp_cmd_name_2', 'gp_cmd_parm']
        ordered_fieldnames = [ 'target_system', 'target_component', 'gp_cmd_name_1', 'gp_cmd_name_2', 'gp_cmd_parm' ]
        format = '<BBBBB'
        native_format = bytearray('<BBBBB', 'ascii')
        orders = [0, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 43

        def __init__(self, target_system, target_component, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_parm):
                MAVLink_message.__init__(self, MAVLink_gopro_command_message.id, MAVLink_gopro_command_message.name)
                self._fieldnames = MAVLink_gopro_command_message.fieldnames
                self.target_system = target_system
                self.target_component = target_component
                self.gp_cmd_name_1 = gp_cmd_name_1
                self.gp_cmd_name_2 = gp_cmd_name_2
                self.gp_cmd_parm = gp_cmd_parm

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 43, struct.pack('<BBBBB', self.target_system, self.target_component, self.gp_cmd_name_1, self.gp_cmd_name_2, self.gp_cmd_parm))

class MAVLink_gopro_response_message(MAVLink_message):
        '''
        Response to a command sent to a HeroBus attached GoPro with a
        GOPRO_COMMAND message.  Contains response from the camera as
        well as information about any errors encountered while
        attempting to communicate with the camera
        '''
        id = MAVLINK_MSG_ID_GOPRO_RESPONSE
        name = 'GOPRO_RESPONSE'
        fieldnames = ['gp_cmd_name_1', 'gp_cmd_name_2', 'gp_cmd_response_status', 'gp_cmd_response_argument', 'gp_cmd_result']
        ordered_fieldnames = [ 'gp_cmd_result', 'gp_cmd_name_1', 'gp_cmd_name_2', 'gp_cmd_response_status', 'gp_cmd_response_argument' ]
        format = '<HBBBB'
        native_format = bytearray('<HBBBB', 'ascii')
        orders = [1, 2, 3, 4, 0]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 149

        def __init__(self, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_response_status, gp_cmd_response_argument, gp_cmd_result):
                MAVLink_message.__init__(self, MAVLink_gopro_response_message.id, MAVLink_gopro_response_message.name)
                self._fieldnames = MAVLink_gopro_response_message.fieldnames
                self.gp_cmd_name_1 = gp_cmd_name_1
                self.gp_cmd_name_2 = gp_cmd_name_2
                self.gp_cmd_response_status = gp_cmd_response_status
                self.gp_cmd_response_argument = gp_cmd_response_argument
                self.gp_cmd_result = gp_cmd_result

        def pack(self, mav):
                return MAVLink_message.pack(self, mav, 149, struct.pack('<HBBBB', self.gp_cmd_result, self.gp_cmd_name_1, self.gp_cmd_name_2, self.gp_cmd_response_status, self.gp_cmd_response_argument))


mavlink_map = {
        MAVLINK_MSG_ID_TUNED_FREQUENCY : MAVLink_tuned_frequency_message,
        MAVLINK_MSG_ID_PHASE_OFFSET : MAVLink_phase_offset_message,
        MAVLINK_MSG_ID_SENSOR_OFFSETS : MAVLink_sensor_offsets_message,
        MAVLINK_MSG_ID_SET_MAG_OFFSETS : MAVLink_set_mag_offsets_message,
        MAVLINK_MSG_ID_MEMINFO : MAVLink_meminfo_message,
        MAVLINK_MSG_ID_AP_ADC : MAVLink_ap_adc_message,
        MAVLINK_MSG_ID_DIGICAM_CONFIGURE : MAVLink_digicam_configure_message,
        MAVLINK_MSG_ID_DIGICAM_CONTROL : MAVLink_digicam_control_message,
        MAVLINK_MSG_ID_MOUNT_CONFIGURE : MAVLink_mount_configure_message,
        MAVLINK_MSG_ID_MOUNT_CONTROL : MAVLink_mount_control_message,
        MAVLINK_MSG_ID_MOUNT_STATUS : MAVLink_mount_status_message,
        MAVLINK_MSG_ID_FENCE_POINT : MAVLink_fence_point_message,
        MAVLINK_MSG_ID_FENCE_FETCH_POINT : MAVLink_fence_fetch_point_message,
        MAVLINK_MSG_ID_FENCE_STATUS : MAVLink_fence_status_message,
        MAVLINK_MSG_ID_AHRS : MAVLink_ahrs_message,
        MAVLINK_MSG_ID_SIMSTATE : MAVLink_simstate_message,
        MAVLINK_MSG_ID_HWSTATUS : MAVLink_hwstatus_message,
        MAVLINK_MSG_ID_RADIO : MAVLink_radio_message,
        MAVLINK_MSG_ID_LIMITS_STATUS : MAVLink_limits_status_message,
        MAVLINK_MSG_ID_WIND : MAVLink_wind_message,
        MAVLINK_MSG_ID_DATA16 : MAVLink_data16_message,
        MAVLINK_MSG_ID_DATA32 : MAVLink_data32_message,
        MAVLINK_MSG_ID_DATA64 : MAVLink_data64_message,
        MAVLINK_MSG_ID_DATA96 : MAVLink_data96_message,
        MAVLINK_MSG_ID_RANGEFINDER : MAVLink_rangefinder_message,
        MAVLINK_MSG_ID_AIRSPEED_AUTOCAL : MAVLink_airspeed_autocal_message,
        MAVLINK_MSG_ID_RALLY_POINT : MAVLink_rally_point_message,
        MAVLINK_MSG_ID_RALLY_FETCH_POINT : MAVLink_rally_fetch_point_message,
        MAVLINK_MSG_ID_COMPASSMOT_STATUS : MAVLink_compassmot_status_message,
        MAVLINK_MSG_ID_AHRS2 : MAVLink_ahrs2_message,
        MAVLINK_MSG_ID_CAMERA_STATUS : MAVLink_camera_status_message,
        MAVLINK_MSG_ID_CAMERA_FEEDBACK : MAVLink_camera_feedback_message,
        MAVLINK_MSG_ID_BATTERY2 : MAVLink_battery2_message,
        MAVLINK_MSG_ID_AHRS3 : MAVLink_ahrs3_message,
        MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST : MAVLink_autopilot_version_request_message,
        MAVLINK_MSG_ID_LED_CONTROL : MAVLink_led_control_message,
        MAVLINK_MSG_ID_MAG_CAL_PROGRESS : MAVLink_mag_cal_progress_message,
        MAVLINK_MSG_ID_MAG_CAL_REPORT : MAVLink_mag_cal_report_message,
        MAVLINK_MSG_ID_EKF_STATUS_REPORT : MAVLink_ekf_status_report_message,
        MAVLINK_MSG_ID_PID_TUNING : MAVLink_pid_tuning_message,
        MAVLINK_MSG_ID_GIMBAL_REPORT : MAVLink_gimbal_report_message,
        MAVLINK_MSG_ID_GIMBAL_CONTROL : MAVLink_gimbal_control_message,
        MAVLINK_MSG_ID_GIMBAL_RESET : MAVLink_gimbal_reset_message,
        MAVLINK_MSG_ID_GIMBAL_AXIS_CALIBRATION_PROGRESS : MAVLink_gimbal_axis_calibration_progress_message,
        MAVLINK_MSG_ID_GIMBAL_SET_HOME_OFFSETS : MAVLink_gimbal_set_home_offsets_message,
        MAVLINK_MSG_ID_GIMBAL_HOME_OFFSET_CALIBRATION_RESULT : MAVLink_gimbal_home_offset_calibration_result_message,
        MAVLINK_MSG_ID_GIMBAL_SET_FACTORY_PARAMETERS : MAVLink_gimbal_set_factory_parameters_message,
        MAVLINK_MSG_ID_GIMBAL_FACTORY_PARAMETERS_LOADED : MAVLink_gimbal_factory_parameters_loaded_message,
        MAVLINK_MSG_ID_GIMBAL_ERASE_FIRMWARE_AND_CONFIG : MAVLink_gimbal_erase_firmware_and_config_message,
        MAVLINK_MSG_ID_GIMBAL_PERFORM_FACTORY_TESTS : MAVLink_gimbal_perform_factory_tests_message,
        MAVLINK_MSG_ID_GIMBAL_REPORT_FACTORY_TESTS_PROGRESS : MAVLink_gimbal_report_factory_tests_progress_message,
        MAVLINK_MSG_ID_GOPRO_POWER_ON : MAVLink_gopro_power_on_message,
        MAVLINK_MSG_ID_GOPRO_POWER_OFF : MAVLink_gopro_power_off_message,
        MAVLINK_MSG_ID_GOPRO_COMMAND : MAVLink_gopro_command_message,
        MAVLINK_MSG_ID_GOPRO_RESPONSE : MAVLink_gopro_response_message,
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.expected_length = 8
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()
                if native_supported and (use_native or native_testing or native_force):
                    print("NOTE: mavnative is currently beta-test code")
                    self.native = mavnative.NativeConnection(MAVLink_message, mavlink_map)
                else:
                    self.native = None
                if native_testing:
                    self.test_buf = bytearray()

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            if self.native:
                ret = self.native.expected_length - len(self.buf)
            else:
                ret = self.expected_length - len(self.buf)
            
            if ret <= 0:
                return 1
            return ret

        def __parse_char_native(self, c):
            '''this method exists only to see in profiling results'''
            m = self.native.parse_chars(c)
            return m

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            if self.native:
                if native_testing:
                    self.test_buf.extend(c)
                    m = self.__parse_char_native(self.test_buf)
                    m2 = self.__parse_char_legacy()
                    if m2 != m:
                        print("Native: %s\nLegacy: %s\n" % (m, m2))
                        raise Exception('Native vs. Legacy mismatch')
                else:
                    m = self.__parse_char_native(self.buf)
            else:
                m = self.__parse_char_legacy()

            if m != None:
                self.total_packets_received += 1
                self.__callbacks(m)

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            if len(self.buf) >= 1 and self.buf[0] != 254:
                magic = self.buf[0]
                self.buf = self.buf[1:]
                if self.robust_parsing:
                    m = MAVLink_bad_data(chr(magic), "Bad prefix")
                    self.expected_length = 8
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if len(self.buf) >= 2:
                if sys.version_info[0] < 3:
                    (magic, self.expected_length) = struct.unpack('BB', str(self.buf[0:2])) # bytearrays are not supported in py 2.7.3
                else:
                    (magic, self.expected_length) = struct.unpack('BB', self.buf[0:2])
                self.expected_length += 8
            if self.expected_length >= 8 and len(self.buf) >= self.expected_length:
                mbuf = array.array('B', self.buf[0:self.expected_length])
                self.buf = self.buf[self.expected_length:]
                self.expected_length = 8
                if self.robust_parsing:
                    try:
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                try:
                    magic, mlen, seq, srcSystem, srcComponent, msgId = struct.unpack('cBBBBB', msgbuf[:6])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                if ord(magic) != 254:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-8:
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u' % (len(msgbuf)-8, mlen, msgId))

                if not msgId in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %u' % msgId)

                # decode the payload
                type = mavlink_map[msgId]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = struct.unpack('<H', msgbuf[-2:])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-2]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                try:
                    t = struct.unpack(fmt, msgbuf[6:-2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(msgbuf[6:-2]), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if isinstance(tlist[i], str):
                        tlist[i] = str(MAVString(tlist[i]))
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-2]
                m._crc = crc
                m._header = MAVLink_header(msgId, mlen, seq, srcSystem, srcComponent)
                return m
        def tuned_frequency_encode(self, tuned_freq):
                '''
                Control the tuned frequency of an SDR

                tuned_freq                : Tuned Frequency (float)

                '''
                return MAVLink_tuned_frequency_message(tuned_freq)

        def tuned_frequency_send(self, tuned_freq):
                '''
                Control the tuned frequency of an SDR

                tuned_freq                : Tuned Frequency (float)

                '''
                return self.send(self.tuned_frequency_encode(tuned_freq))

        def phase_offset_encode(self, phase_offset):
                '''
                The phase offset of a signal received by an SDR

                phase_offset              : Phase Offset (uint16_t)

                '''
                return MAVLink_phase_offset_message(phase_offset)

        def phase_offset_send(self, phase_offset):
                '''
                The phase offset of a signal received by an SDR

                phase_offset              : Phase Offset (uint16_t)

                '''
                return self.send(self.phase_offset_encode(phase_offset))

        def sensor_offsets_encode(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):
                '''
                Offsets and calibrations values for hardware         sensors. This
                makes it easier to debug the calibration process.

                mag_ofs_x                 : magnetometer X offset (int16_t)
                mag_ofs_y                 : magnetometer Y offset (int16_t)
                mag_ofs_z                 : magnetometer Z offset (int16_t)
                mag_declination           : magnetic declination (radians) (float)
                raw_press                 : raw pressure from barometer (int32_t)
                raw_temp                  : raw temperature from barometer (int32_t)
                gyro_cal_x                : gyro X calibration (float)
                gyro_cal_y                : gyro Y calibration (float)
                gyro_cal_z                : gyro Z calibration (float)
                accel_cal_x               : accel X calibration (float)
                accel_cal_y               : accel Y calibration (float)
                accel_cal_z               : accel Z calibration (float)

                '''
                return MAVLink_sensor_offsets_message(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z)

        def sensor_offsets_send(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):
                '''
                Offsets and calibrations values for hardware         sensors. This
                makes it easier to debug the calibration process.

                mag_ofs_x                 : magnetometer X offset (int16_t)
                mag_ofs_y                 : magnetometer Y offset (int16_t)
                mag_ofs_z                 : magnetometer Z offset (int16_t)
                mag_declination           : magnetic declination (radians) (float)
                raw_press                 : raw pressure from barometer (int32_t)
                raw_temp                  : raw temperature from barometer (int32_t)
                gyro_cal_x                : gyro X calibration (float)
                gyro_cal_y                : gyro Y calibration (float)
                gyro_cal_z                : gyro Z calibration (float)
                accel_cal_x               : accel X calibration (float)
                accel_cal_y               : accel Y calibration (float)
                accel_cal_z               : accel Z calibration (float)

                '''
                return self.send(self.sensor_offsets_encode(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z))

        def set_mag_offsets_encode(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):
                '''
                Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the
                magnetometer offsets

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mag_ofs_x                 : magnetometer X offset (int16_t)
                mag_ofs_y                 : magnetometer Y offset (int16_t)
                mag_ofs_z                 : magnetometer Z offset (int16_t)

                '''
                return MAVLink_set_mag_offsets_message(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z)

        def set_mag_offsets_send(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):
                '''
                Deprecated. Use MAV_CMD_PREFLIGHT_SET_SENSOR_OFFSETS instead. Set the
                magnetometer offsets

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mag_ofs_x                 : magnetometer X offset (int16_t)
                mag_ofs_y                 : magnetometer Y offset (int16_t)
                mag_ofs_z                 : magnetometer Z offset (int16_t)

                '''
                return self.send(self.set_mag_offsets_encode(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z))

        def meminfo_encode(self, brkval, freemem):
                '''
                state of APM memory

                brkval                    : heap top (uint16_t)
                freemem                   : free memory (uint16_t)

                '''
                return MAVLink_meminfo_message(brkval, freemem)

        def meminfo_send(self, brkval, freemem):
                '''
                state of APM memory

                brkval                    : heap top (uint16_t)
                freemem                   : free memory (uint16_t)

                '''
                return self.send(self.meminfo_encode(brkval, freemem))

        def ap_adc_encode(self, adc1, adc2, adc3, adc4, adc5, adc6):
                '''
                raw ADC output

                adc1                      : ADC output 1 (uint16_t)
                adc2                      : ADC output 2 (uint16_t)
                adc3                      : ADC output 3 (uint16_t)
                adc4                      : ADC output 4 (uint16_t)
                adc5                      : ADC output 5 (uint16_t)
                adc6                      : ADC output 6 (uint16_t)

                '''
                return MAVLink_ap_adc_message(adc1, adc2, adc3, adc4, adc5, adc6)

        def ap_adc_send(self, adc1, adc2, adc3, adc4, adc5, adc6):
                '''
                raw ADC output

                adc1                      : ADC output 1 (uint16_t)
                adc2                      : ADC output 2 (uint16_t)
                adc3                      : ADC output 3 (uint16_t)
                adc4                      : ADC output 4 (uint16_t)
                adc5                      : ADC output 5 (uint16_t)
                adc6                      : ADC output 6 (uint16_t)

                '''
                return self.send(self.ap_adc_encode(adc1, adc2, adc3, adc4, adc5, adc6))

        def digicam_configure_encode(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):
                '''
                Configure on-board Camera Control System.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore) (uint8_t)
                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore) (uint16_t)
                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore) (uint8_t)
                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore) (uint8_t)
                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore) (uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)
                engine_cut_off            : Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) (uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)
                extra_value               : Correspondent value to given extra_param (float)

                '''
                return MAVLink_digicam_configure_message(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value)

        def digicam_configure_send(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):
                '''
                Configure on-board Camera Control System.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, Etc (0 means ignore) (uint8_t)
                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore) (uint16_t)
                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore) (uint8_t)
                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore) (uint8_t)
                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore) (uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)
                engine_cut_off            : Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off) (uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)
                extra_value               : Correspondent value to given extra_param (float)

                '''
                return self.send(self.digicam_configure_encode(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value))

        def digicam_control_encode(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):
                '''
                Control on-board Camera Control System to take shots.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens (uint8_t)
                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore) (uint8_t)
                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position (int8_t)
                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus (uint8_t)
                shot                      : 0: ignore, 1: shot or start filming (uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)
                extra_value               : Correspondent value to given extra_param (float)

                '''
                return MAVLink_digicam_control_message(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value)

        def digicam_control_send(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):
                '''
                Control on-board Camera Control System to take shots.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens (uint8_t)
                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore) (uint8_t)
                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position (int8_t)
                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus (uint8_t)
                shot                      : 0: ignore, 1: shot or start filming (uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once (uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore) (uint8_t)
                extra_value               : Correspondent value to given extra_param (float)

                '''
                return self.send(self.digicam_control_encode(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value))

        def mount_configure_encode(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):
                '''
                Message to configure a camera mount, directional antenna, etc.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mount_mode                : mount operating mode (see MAV_MOUNT_MODE enum) (uint8_t)
                stab_roll                 : (1 = yes, 0 = no) (uint8_t)
                stab_pitch                : (1 = yes, 0 = no) (uint8_t)
                stab_yaw                  : (1 = yes, 0 = no) (uint8_t)

                '''
                return MAVLink_mount_configure_message(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw)

        def mount_configure_send(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):
                '''
                Message to configure a camera mount, directional antenna, etc.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                mount_mode                : mount operating mode (see MAV_MOUNT_MODE enum) (uint8_t)
                stab_roll                 : (1 = yes, 0 = no) (uint8_t)
                stab_pitch                : (1 = yes, 0 = no) (uint8_t)
                stab_yaw                  : (1 = yes, 0 = no) (uint8_t)

                '''
                return self.send(self.mount_configure_encode(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw))

        def mount_control_encode(self, target_system, target_component, input_a, input_b, input_c, save_position):
                '''
                Message to control a camera mount, directional antenna, etc.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                input_a                   : pitch(deg*100) or lat, depending on mount mode (int32_t)
                input_b                   : roll(deg*100) or lon depending on mount mode (int32_t)
                input_c                   : yaw(deg*100) or alt (in cm) depending on mount mode (int32_t)
                save_position             : if "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING) (uint8_t)

                '''
                return MAVLink_mount_control_message(target_system, target_component, input_a, input_b, input_c, save_position)

        def mount_control_send(self, target_system, target_component, input_a, input_b, input_c, save_position):
                '''
                Message to control a camera mount, directional antenna, etc.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                input_a                   : pitch(deg*100) or lat, depending on mount mode (int32_t)
                input_b                   : roll(deg*100) or lon depending on mount mode (int32_t)
                input_c                   : yaw(deg*100) or alt (in cm) depending on mount mode (int32_t)
                save_position             : if "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING) (uint8_t)

                '''
                return self.send(self.mount_control_encode(target_system, target_component, input_a, input_b, input_c, save_position))

        def mount_status_encode(self, target_system, target_component, pointing_a, pointing_b, pointing_c):
                '''
                Message with some status from APM to GCS about camera or antenna mount

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                pointing_a                : pitch(deg*100) (int32_t)
                pointing_b                : roll(deg*100) (int32_t)
                pointing_c                : yaw(deg*100) (int32_t)

                '''
                return MAVLink_mount_status_message(target_system, target_component, pointing_a, pointing_b, pointing_c)

        def mount_status_send(self, target_system, target_component, pointing_a, pointing_b, pointing_c):
                '''
                Message with some status from APM to GCS about camera or antenna mount

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                pointing_a                : pitch(deg*100) (int32_t)
                pointing_b                : roll(deg*100) (int32_t)
                pointing_c                : yaw(deg*100) (int32_t)

                '''
                return self.send(self.mount_status_encode(target_system, target_component, pointing_a, pointing_b, pointing_c))

        def fence_point_encode(self, target_system, target_component, idx, count, lat, lng):
                '''
                A fence point. Used to set a point when from               GCS -> MAV.
                Also used to return a point from MAV -> GCS

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 1, 0 is for return point) (uint8_t)
                count                     : total number of points (for sanity checking) (uint8_t)
                lat                       : Latitude of point (float)
                lng                       : Longitude of point (float)

                '''
                return MAVLink_fence_point_message(target_system, target_component, idx, count, lat, lng)

        def fence_point_send(self, target_system, target_component, idx, count, lat, lng):
                '''
                A fence point. Used to set a point when from               GCS -> MAV.
                Also used to return a point from MAV -> GCS

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 1, 0 is for return point) (uint8_t)
                count                     : total number of points (for sanity checking) (uint8_t)
                lat                       : Latitude of point (float)
                lng                       : Longitude of point (float)

                '''
                return self.send(self.fence_point_encode(target_system, target_component, idx, count, lat, lng))

        def fence_fetch_point_encode(self, target_system, target_component, idx):
                '''
                Request a current fence point from MAV

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 1, 0 is for return point) (uint8_t)

                '''
                return MAVLink_fence_fetch_point_message(target_system, target_component, idx)

        def fence_fetch_point_send(self, target_system, target_component, idx):
                '''
                Request a current fence point from MAV

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 1, 0 is for return point) (uint8_t)

                '''
                return self.send(self.fence_fetch_point_encode(target_system, target_component, idx))

        def fence_status_encode(self, breach_status, breach_count, breach_type, breach_time):
                '''
                Status of geo-fencing. Sent in extended             status stream when
                fencing enabled

                breach_status             : 0 if currently inside fence, 1 if outside (uint8_t)
                breach_count              : number of fence breaches (uint16_t)
                breach_type               : last breach type (see FENCE_BREACH_* enum) (uint8_t)
                breach_time               : time of last breach in milliseconds since boot (uint32_t)

                '''
                return MAVLink_fence_status_message(breach_status, breach_count, breach_type, breach_time)

        def fence_status_send(self, breach_status, breach_count, breach_type, breach_time):
                '''
                Status of geo-fencing. Sent in extended             status stream when
                fencing enabled

                breach_status             : 0 if currently inside fence, 1 if outside (uint8_t)
                breach_count              : number of fence breaches (uint16_t)
                breach_type               : last breach type (see FENCE_BREACH_* enum) (uint8_t)
                breach_time               : time of last breach in milliseconds since boot (uint32_t)

                '''
                return self.send(self.fence_status_encode(breach_status, breach_count, breach_type, breach_time))

        def ahrs_encode(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                '''
                Status of DCM attitude estimator

                omegaIx                   : X gyro drift estimate rad/s (float)
                omegaIy                   : Y gyro drift estimate rad/s (float)
                omegaIz                   : Z gyro drift estimate rad/s (float)
                accel_weight              : average accel_weight (float)
                renorm_val                : average renormalisation value (float)
                error_rp                  : average error_roll_pitch value (float)
                error_yaw                 : average error_yaw value (float)

                '''
                return MAVLink_ahrs_message(omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw)

        def ahrs_send(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                '''
                Status of DCM attitude estimator

                omegaIx                   : X gyro drift estimate rad/s (float)
                omegaIy                   : Y gyro drift estimate rad/s (float)
                omegaIz                   : Z gyro drift estimate rad/s (float)
                accel_weight              : average accel_weight (float)
                renorm_val                : average renormalisation value (float)
                error_rp                  : average error_roll_pitch value (float)
                error_yaw                 : average error_yaw value (float)

                '''
                return self.send(self.ahrs_encode(omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw))

        def simstate_encode(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng):
                '''
                Status of simulation environment, if used

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                xacc                      : X acceleration m/s/s (float)
                yacc                      : Y acceleration m/s/s (float)
                zacc                      : Z acceleration m/s/s (float)
                xgyro                     : Angular speed around X axis rad/s (float)
                ygyro                     : Angular speed around Y axis rad/s (float)
                zgyro                     : Angular speed around Z axis rad/s (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)

                '''
                return MAVLink_simstate_message(roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng)

        def simstate_send(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng):
                '''
                Status of simulation environment, if used

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                xacc                      : X acceleration m/s/s (float)
                yacc                      : Y acceleration m/s/s (float)
                zacc                      : Z acceleration m/s/s (float)
                xgyro                     : Angular speed around X axis rad/s (float)
                ygyro                     : Angular speed around Y axis rad/s (float)
                zgyro                     : Angular speed around Z axis rad/s (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)

                '''
                return self.send(self.simstate_encode(roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng))

        def hwstatus_encode(self, Vcc, I2Cerr):
                '''
                Status of key hardware

                Vcc                       : board voltage (mV) (uint16_t)
                I2Cerr                    : I2C error count (uint8_t)

                '''
                return MAVLink_hwstatus_message(Vcc, I2Cerr)

        def hwstatus_send(self, Vcc, I2Cerr):
                '''
                Status of key hardware

                Vcc                       : board voltage (mV) (uint16_t)
                I2Cerr                    : I2C error count (uint8_t)

                '''
                return self.send(self.hwstatus_encode(Vcc, I2Cerr))

        def radio_encode(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed):
                '''
                Status generated by radio

                rssi                      : local signal strength (uint8_t)
                remrssi                   : remote signal strength (uint8_t)
                txbuf                     : how full the tx buffer is as a percentage (uint8_t)
                noise                     : background noise level (uint8_t)
                remnoise                  : remote background noise level (uint8_t)
                rxerrors                  : receive errors (uint16_t)
                fixed                     : count of error corrected packets (uint16_t)

                '''
                return MAVLink_radio_message(rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed)

        def radio_send(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed):
                '''
                Status generated by radio

                rssi                      : local signal strength (uint8_t)
                remrssi                   : remote signal strength (uint8_t)
                txbuf                     : how full the tx buffer is as a percentage (uint8_t)
                noise                     : background noise level (uint8_t)
                remnoise                  : remote background noise level (uint8_t)
                rxerrors                  : receive errors (uint16_t)
                fixed                     : count of error corrected packets (uint16_t)

                '''
                return self.send(self.radio_encode(rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed))

        def limits_status_encode(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):
                '''
                Status of AP_Limits. Sent in extended             status stream when
                AP_Limits is enabled

                limits_state              : state of AP_Limits, (see enum LimitState, LIMITS_STATE) (uint8_t)
                last_trigger              : time of last breach in milliseconds since boot (uint32_t)
                last_action               : time of last recovery action in milliseconds since boot (uint32_t)
                last_recovery             : time of last successful recovery in milliseconds since boot (uint32_t)
                last_clear                : time of last all-clear in milliseconds since boot (uint32_t)
                breach_count              : number of fence breaches (uint16_t)
                mods_enabled              : AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)
                mods_required             : AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)
                mods_triggered            : AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)

                '''
                return MAVLink_limits_status_message(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered)

        def limits_status_send(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):
                '''
                Status of AP_Limits. Sent in extended             status stream when
                AP_Limits is enabled

                limits_state              : state of AP_Limits, (see enum LimitState, LIMITS_STATE) (uint8_t)
                last_trigger              : time of last breach in milliseconds since boot (uint32_t)
                last_action               : time of last recovery action in milliseconds since boot (uint32_t)
                last_recovery             : time of last successful recovery in milliseconds since boot (uint32_t)
                last_clear                : time of last all-clear in milliseconds since boot (uint32_t)
                breach_count              : number of fence breaches (uint16_t)
                mods_enabled              : AP_Limit_Module bitfield of enabled modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)
                mods_required             : AP_Limit_Module bitfield of required modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)
                mods_triggered            : AP_Limit_Module bitfield of triggered modules, (see enum moduleid or LIMIT_MODULE) (uint8_t)

                '''
                return self.send(self.limits_status_encode(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered))

        def wind_encode(self, direction, speed, speed_z):
                '''
                Wind estimation

                direction                 : wind direction that wind is coming from (degrees) (float)
                speed                     : wind speed in ground plane (m/s) (float)
                speed_z                   : vertical wind speed (m/s) (float)

                '''
                return MAVLink_wind_message(direction, speed, speed_z)

        def wind_send(self, direction, speed, speed_z):
                '''
                Wind estimation

                direction                 : wind direction that wind is coming from (degrees) (float)
                speed                     : wind speed in ground plane (m/s) (float)
                speed_z                   : vertical wind speed (m/s) (float)

                '''
                return self.send(self.wind_encode(direction, speed, speed_z))

        def data16_encode(self, type, len, data):
                '''
                Data packet, size 16

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return MAVLink_data16_message(type, len, data)

        def data16_send(self, type, len, data):
                '''
                Data packet, size 16

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return self.send(self.data16_encode(type, len, data))

        def data32_encode(self, type, len, data):
                '''
                Data packet, size 32

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return MAVLink_data32_message(type, len, data)

        def data32_send(self, type, len, data):
                '''
                Data packet, size 32

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return self.send(self.data32_encode(type, len, data))

        def data64_encode(self, type, len, data):
                '''
                Data packet, size 64

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return MAVLink_data64_message(type, len, data)

        def data64_send(self, type, len, data):
                '''
                Data packet, size 64

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return self.send(self.data64_encode(type, len, data))

        def data96_encode(self, type, len, data):
                '''
                Data packet, size 96

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return MAVLink_data96_message(type, len, data)

        def data96_send(self, type, len, data):
                '''
                Data packet, size 96

                type                      : data type (uint8_t)
                len                       : data length (uint8_t)
                data                      : raw data (uint8_t)

                '''
                return self.send(self.data96_encode(type, len, data))

        def rangefinder_encode(self, distance, voltage):
                '''
                Rangefinder reporting

                distance                  : distance in meters (float)
                voltage                   : raw voltage if available, zero otherwise (float)

                '''
                return MAVLink_rangefinder_message(distance, voltage)

        def rangefinder_send(self, distance, voltage):
                '''
                Rangefinder reporting

                distance                  : distance in meters (float)
                voltage                   : raw voltage if available, zero otherwise (float)

                '''
                return self.send(self.rangefinder_encode(distance, voltage))

        def airspeed_autocal_encode(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz):
                '''
                Airspeed auto-calibration

                vx                        : GPS velocity north m/s (float)
                vy                        : GPS velocity east m/s (float)
                vz                        : GPS velocity down m/s (float)
                diff_pressure             : Differential pressure pascals (float)
                EAS2TAS                   : Estimated to true airspeed ratio (float)
                ratio                     : Airspeed ratio (float)
                state_x                   : EKF state x (float)
                state_y                   : EKF state y (float)
                state_z                   : EKF state z (float)
                Pax                       : EKF Pax (float)
                Pby                       : EKF Pby (float)
                Pcz                       : EKF Pcz (float)

                '''
                return MAVLink_airspeed_autocal_message(vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz)

        def airspeed_autocal_send(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz):
                '''
                Airspeed auto-calibration

                vx                        : GPS velocity north m/s (float)
                vy                        : GPS velocity east m/s (float)
                vz                        : GPS velocity down m/s (float)
                diff_pressure             : Differential pressure pascals (float)
                EAS2TAS                   : Estimated to true airspeed ratio (float)
                ratio                     : Airspeed ratio (float)
                state_x                   : EKF state x (float)
                state_y                   : EKF state y (float)
                state_z                   : EKF state z (float)
                Pax                       : EKF Pax (float)
                Pby                       : EKF Pby (float)
                Pcz                       : EKF Pcz (float)

                '''
                return self.send(self.airspeed_autocal_encode(vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz))

        def rally_point_encode(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags):
                '''
                A rally point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 0) (uint8_t)
                count                     : total number of points (for sanity checking) (uint8_t)
                lat                       : Latitude of point in degrees * 1E7 (int32_t)
                lng                       : Longitude of point in degrees * 1E7 (int32_t)
                alt                       : Transit / loiter altitude in meters relative to home (int16_t)
                break_alt                 : Break altitude in meters relative to home (int16_t)
                land_dir                  : Heading to aim for when landing. In centi-degrees. (uint16_t)
                flags                     : See RALLY_FLAGS enum for definition of the bitmask. (uint8_t)

                '''
                return MAVLink_rally_point_message(target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags)

        def rally_point_send(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags):
                '''
                A rally point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 0) (uint8_t)
                count                     : total number of points (for sanity checking) (uint8_t)
                lat                       : Latitude of point in degrees * 1E7 (int32_t)
                lng                       : Longitude of point in degrees * 1E7 (int32_t)
                alt                       : Transit / loiter altitude in meters relative to home (int16_t)
                break_alt                 : Break altitude in meters relative to home (int16_t)
                land_dir                  : Heading to aim for when landing. In centi-degrees. (uint16_t)
                flags                     : See RALLY_FLAGS enum for definition of the bitmask. (uint8_t)

                '''
                return self.send(self.rally_point_encode(target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags))

        def rally_fetch_point_encode(self, target_system, target_component, idx):
                '''
                Request a current rally point from MAV. MAV should respond with a
                RALLY_POINT message. MAV should not respond if the
                request is invalid.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 0) (uint8_t)

                '''
                return MAVLink_rally_fetch_point_message(target_system, target_component, idx)

        def rally_fetch_point_send(self, target_system, target_component, idx):
                '''
                Request a current rally point from MAV. MAV should respond with a
                RALLY_POINT message. MAV should not respond if the
                request is invalid.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                idx                       : point index (first point is 0) (uint8_t)

                '''
                return self.send(self.rally_fetch_point_encode(target_system, target_component, idx))

        def compassmot_status_encode(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ):
                '''
                Status of compassmot calibration

                throttle                  : throttle (percent*10) (uint16_t)
                current                   : current (amps) (float)
                interference              : interference (percent) (uint16_t)
                CompensationX             : Motor Compensation X (float)
                CompensationY             : Motor Compensation Y (float)
                CompensationZ             : Motor Compensation Z (float)

                '''
                return MAVLink_compassmot_status_message(throttle, current, interference, CompensationX, CompensationY, CompensationZ)

        def compassmot_status_send(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ):
                '''
                Status of compassmot calibration

                throttle                  : throttle (percent*10) (uint16_t)
                current                   : current (amps) (float)
                interference              : interference (percent) (uint16_t)
                CompensationX             : Motor Compensation X (float)
                CompensationY             : Motor Compensation Y (float)
                CompensationZ             : Motor Compensation Z (float)

                '''
                return self.send(self.compassmot_status_encode(throttle, current, interference, CompensationX, CompensationY, CompensationZ))

        def ahrs2_encode(self, roll, pitch, yaw, altitude, lat, lng):
                '''
                Status of secondary AHRS filter if available

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                altitude                  : Altitude (MSL) (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)

                '''
                return MAVLink_ahrs2_message(roll, pitch, yaw, altitude, lat, lng)

        def ahrs2_send(self, roll, pitch, yaw, altitude, lat, lng):
                '''
                Status of secondary AHRS filter if available

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                altitude                  : Altitude (MSL) (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)

                '''
                return self.send(self.ahrs2_encode(roll, pitch, yaw, altitude, lat, lng))

        def camera_status_encode(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):
                '''
                Camera Event

                time_usec                 : Image timestamp (microseconds since UNIX epoch, according to camera clock) (uint64_t)
                target_system             : System ID (uint8_t)
                cam_idx                   : Camera ID (uint8_t)
                img_idx                   : Image index (uint16_t)
                event_id                  : See CAMERA_STATUS_TYPES enum for definition of the bitmask (uint8_t)
                p1                        : Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p2                        : Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p3                        : Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p4                        : Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)

                '''
                return MAVLink_camera_status_message(time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4)

        def camera_status_send(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):
                '''
                Camera Event

                time_usec                 : Image timestamp (microseconds since UNIX epoch, according to camera clock) (uint64_t)
                target_system             : System ID (uint8_t)
                cam_idx                   : Camera ID (uint8_t)
                img_idx                   : Image index (uint16_t)
                event_id                  : See CAMERA_STATUS_TYPES enum for definition of the bitmask (uint8_t)
                p1                        : Parameter 1 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p2                        : Parameter 2 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p3                        : Parameter 3 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)
                p4                        : Parameter 4 (meaning depends on event, see CAMERA_STATUS_TYPES enum) (float)

                '''
                return self.send(self.camera_status_encode(time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4))

        def camera_feedback_encode(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):
                '''
                Camera Capture Feedback

                time_usec                 : Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB) (uint64_t)
                target_system             : System ID (uint8_t)
                cam_idx                   : Camera ID (uint8_t)
                img_idx                   : Image index (uint16_t)
                lat                       : Latitude in (deg * 1E7) (int32_t)
                lng                       : Longitude in (deg * 1E7) (int32_t)
                alt_msl                   : Altitude Absolute (meters AMSL) (float)
                alt_rel                   : Altitude Relative (meters above HOME location) (float)
                roll                      : Camera Roll angle (earth frame, degrees, +-180) (float)
                pitch                     : Camera Pitch angle (earth frame, degrees, +-180) (float)
                yaw                       : Camera Yaw (earth frame, degrees, 0-360, true) (float)
                foc_len                   : Focal Length (mm) (float)
                flags                     : See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask (uint8_t)

                '''
                return MAVLink_camera_feedback_message(time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags)

        def camera_feedback_send(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):
                '''
                Camera Capture Feedback

                time_usec                 : Image timestamp (microseconds since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB) (uint64_t)
                target_system             : System ID (uint8_t)
                cam_idx                   : Camera ID (uint8_t)
                img_idx                   : Image index (uint16_t)
                lat                       : Latitude in (deg * 1E7) (int32_t)
                lng                       : Longitude in (deg * 1E7) (int32_t)
                alt_msl                   : Altitude Absolute (meters AMSL) (float)
                alt_rel                   : Altitude Relative (meters above HOME location) (float)
                roll                      : Camera Roll angle (earth frame, degrees, +-180) (float)
                pitch                     : Camera Pitch angle (earth frame, degrees, +-180) (float)
                yaw                       : Camera Yaw (earth frame, degrees, 0-360, true) (float)
                foc_len                   : Focal Length (mm) (float)
                flags                     : See CAMERA_FEEDBACK_FLAGS enum for definition of the bitmask (uint8_t)

                '''
                return self.send(self.camera_feedback_encode(time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags))

        def battery2_encode(self, voltage, current_battery):
                '''
                2nd Battery status

                voltage                   : voltage in millivolts (uint16_t)
                current_battery           : Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current (int16_t)

                '''
                return MAVLink_battery2_message(voltage, current_battery)

        def battery2_send(self, voltage, current_battery):
                '''
                2nd Battery status

                voltage                   : voltage in millivolts (uint16_t)
                current_battery           : Battery current, in 10*milliamperes (1 = 10 milliampere), -1: autopilot does not measure the current (int16_t)

                '''
                return self.send(self.battery2_encode(voltage, current_battery))

        def ahrs3_encode(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4):
                '''
                Status of third AHRS filter if available. This is for ANU research
                group (Ali and Sean)

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                altitude                  : Altitude (MSL) (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)
                v1                        : test variable1 (float)
                v2                        : test variable2 (float)
                v3                        : test variable3 (float)
                v4                        : test variable4 (float)

                '''
                return MAVLink_ahrs3_message(roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4)

        def ahrs3_send(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4):
                '''
                Status of third AHRS filter if available. This is for ANU research
                group (Ali and Sean)

                roll                      : Roll angle (rad) (float)
                pitch                     : Pitch angle (rad) (float)
                yaw                       : Yaw angle (rad) (float)
                altitude                  : Altitude (MSL) (float)
                lat                       : Latitude in degrees * 1E7 (int32_t)
                lng                       : Longitude in degrees * 1E7 (int32_t)
                v1                        : test variable1 (float)
                v2                        : test variable2 (float)
                v3                        : test variable3 (float)
                v4                        : test variable4 (float)

                '''
                return self.send(self.ahrs3_encode(roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4))

        def autopilot_version_request_encode(self, target_system, target_component):
                '''
                Request the autopilot version from the system/component.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_autopilot_version_request_message(target_system, target_component)

        def autopilot_version_request_send(self, target_system, target_component):
                '''
                Request the autopilot version from the system/component.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.autopilot_version_request_encode(target_system, target_component))

        def led_control_encode(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):
                '''
                Control vehicle LEDs

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                instance                  : Instance (LED instance to control or 255 for all LEDs) (uint8_t)
                pattern                   : Pattern (see LED_PATTERN_ENUM) (uint8_t)
                custom_len                : Custom Byte Length (uint8_t)
                custom_bytes              : Custom Bytes (uint8_t)

                '''
                return MAVLink_led_control_message(target_system, target_component, instance, pattern, custom_len, custom_bytes)

        def led_control_send(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):
                '''
                Control vehicle LEDs

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                instance                  : Instance (LED instance to control or 255 for all LEDs) (uint8_t)
                pattern                   : Pattern (see LED_PATTERN_ENUM) (uint8_t)
                custom_len                : Custom Byte Length (uint8_t)
                custom_bytes              : Custom Bytes (uint8_t)

                '''
                return self.send(self.led_control_encode(target_system, target_component, instance, pattern, custom_len, custom_bytes))

        def mag_cal_progress_encode(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):
                '''
                Reports progress of compass calibration.

                compass_id                : Compass being calibrated (uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)
                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)
                attempt                   : Attempt number (uint8_t)
                completion_pct            : Completion percentage (uint8_t)
                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid) (uint8_t)
                direction_x               : Body frame direction vector for display (float)
                direction_y               : Body frame direction vector for display (float)
                direction_z               : Body frame direction vector for display (float)

                '''
                return MAVLink_mag_cal_progress_message(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z)

        def mag_cal_progress_send(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):
                '''
                Reports progress of compass calibration.

                compass_id                : Compass being calibrated (uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)
                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)
                attempt                   : Attempt number (uint8_t)
                completion_pct            : Completion percentage (uint8_t)
                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid) (uint8_t)
                direction_x               : Body frame direction vector for display (float)
                direction_y               : Body frame direction vector for display (float)
                direction_z               : Body frame direction vector for display (float)

                '''
                return self.send(self.mag_cal_progress_encode(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z))

        def mag_cal_report_encode(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):
                '''
                Reports results of completed compass calibration. Sent until
                MAG_CAL_ACK received.

                compass_id                : Compass being calibrated (uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)
                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)
                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters (uint8_t)
                fitness                   : RMS milligauss residuals (float)
                ofs_x                     : X offset (float)
                ofs_y                     : Y offset (float)
                ofs_z                     : Z offset (float)
                diag_x                    : X diagonal (matrix 11) (float)
                diag_y                    : Y diagonal (matrix 22) (float)
                diag_z                    : Z diagonal (matrix 33) (float)
                offdiag_x                 : X off-diagonal (matrix 12 and 21) (float)
                offdiag_y                 : Y off-diagonal (matrix 13 and 31) (float)
                offdiag_z                 : Z off-diagonal (matrix 32 and 23) (float)

                '''
                return MAVLink_mag_cal_report_message(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z)

        def mag_cal_report_send(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):
                '''
                Reports results of completed compass calibration. Sent until
                MAG_CAL_ACK received.

                compass_id                : Compass being calibrated (uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated (uint8_t)
                cal_status                : Status (see MAG_CAL_STATUS enum) (uint8_t)
                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters (uint8_t)
                fitness                   : RMS milligauss residuals (float)
                ofs_x                     : X offset (float)
                ofs_y                     : Y offset (float)
                ofs_z                     : Z offset (float)
                diag_x                    : X diagonal (matrix 11) (float)
                diag_y                    : Y diagonal (matrix 22) (float)
                diag_z                    : Z diagonal (matrix 33) (float)
                offdiag_x                 : X off-diagonal (matrix 12 and 21) (float)
                offdiag_y                 : Y off-diagonal (matrix 13 and 31) (float)
                offdiag_z                 : Z off-diagonal (matrix 32 and 23) (float)

                '''
                return self.send(self.mag_cal_report_encode(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z))

        def ekf_status_report_encode(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance):
                '''
                EKF Status message including flags and variances

                flags                     : Flags (uint16_t)
                velocity_variance         : Velocity variance (float)
                pos_horiz_variance        : Horizontal Position variance (float)
                pos_vert_variance         : Vertical Position variance (float)
                compass_variance          : Compass variance (float)
                terrain_alt_variance        : Terrain Altitude variance (float)

                '''
                return MAVLink_ekf_status_report_message(flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance)

        def ekf_status_report_send(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance):
                '''
                EKF Status message including flags and variances

                flags                     : Flags (uint16_t)
                velocity_variance         : Velocity variance (float)
                pos_horiz_variance        : Horizontal Position variance (float)
                pos_vert_variance         : Vertical Position variance (float)
                compass_variance          : Compass variance (float)
                terrain_alt_variance        : Terrain Altitude variance (float)

                '''
                return self.send(self.ekf_status_report_encode(flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance))

        def pid_tuning_encode(self, axis, desired, achieved, FF, P, I, D):
                '''
                PID tuning information

                axis                      : axis (uint8_t)
                desired                   : desired rate (degrees/s) (float)
                achieved                  : achieved rate (degrees/s) (float)
                FF                        : FF component (float)
                P                         : P component (float)
                I                         : I component (float)
                D                         : D component (float)

                '''
                return MAVLink_pid_tuning_message(axis, desired, achieved, FF, P, I, D)

        def pid_tuning_send(self, axis, desired, achieved, FF, P, I, D):
                '''
                PID tuning information

                axis                      : axis (uint8_t)
                desired                   : desired rate (degrees/s) (float)
                achieved                  : achieved rate (degrees/s) (float)
                FF                        : FF component (float)
                P                         : P component (float)
                I                         : I component (float)
                D                         : D component (float)

                '''
                return self.send(self.pid_tuning_encode(axis, desired, achieved, FF, P, I, D))

        def gimbal_report_encode(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):
                '''
                3 axis gimbal mesuraments

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                delta_time                : Time since last update (seconds) (float)
                delta_angle_x             : Delta angle X (radians) (float)
                delta_angle_y             : Delta angle Y (radians) (float)
                delta_angle_z             : Delta angle X (radians) (float)
                delta_velocity_x          : Delta velocity X (m/s) (float)
                delta_velocity_y          : Delta velocity Y (m/s) (float)
                delta_velocity_z          : Delta velocity Z (m/s) (float)
                joint_roll                : Joint ROLL (radians) (float)
                joint_el                  : Joint EL (radians) (float)
                joint_az                  : Joint AZ (radians) (float)

                '''
                return MAVLink_gimbal_report_message(target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az)

        def gimbal_report_send(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):
                '''
                3 axis gimbal mesuraments

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                delta_time                : Time since last update (seconds) (float)
                delta_angle_x             : Delta angle X (radians) (float)
                delta_angle_y             : Delta angle Y (radians) (float)
                delta_angle_z             : Delta angle X (radians) (float)
                delta_velocity_x          : Delta velocity X (m/s) (float)
                delta_velocity_y          : Delta velocity Y (m/s) (float)
                delta_velocity_z          : Delta velocity Z (m/s) (float)
                joint_roll                : Joint ROLL (radians) (float)
                joint_el                  : Joint EL (radians) (float)
                joint_az                  : Joint AZ (radians) (float)

                '''
                return self.send(self.gimbal_report_encode(target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az))

        def gimbal_control_encode(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):
                '''
                Control message for rate gimbal

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                demanded_rate_x           : Demanded angular rate X (rad/s) (float)
                demanded_rate_y           : Demanded angular rate Y (rad/s) (float)
                demanded_rate_z           : Demanded angular rate Z (rad/s) (float)

                '''
                return MAVLink_gimbal_control_message(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z)

        def gimbal_control_send(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):
                '''
                Control message for rate gimbal

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                demanded_rate_x           : Demanded angular rate X (rad/s) (float)
                demanded_rate_y           : Demanded angular rate Y (rad/s) (float)
                demanded_rate_z           : Demanded angular rate Z (rad/s) (float)

                '''
                return self.send(self.gimbal_control_encode(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z))

        def gimbal_reset_encode(self, target_system, target_component):
                '''
                Causes the gimbal to reset and boot as if it was just powered on

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_gimbal_reset_message(target_system, target_component)

        def gimbal_reset_send(self, target_system, target_component):
                '''
                Causes the gimbal to reset and boot as if it was just powered on

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.gimbal_reset_encode(target_system, target_component))

        def gimbal_axis_calibration_progress_encode(self, calibration_axis, calibration_progress, calibration_status):
                '''
                Reports progress and success or failure of gimbal axis calibration
                procedure

                calibration_axis          : Which gimbal axis we're reporting calibration progress for (uint8_t)
                calibration_progress        : The current calibration progress for this axis, 0x64=100% (uint8_t)
                calibration_status        : The status of the running calibration (uint8_t)

                '''
                return MAVLink_gimbal_axis_calibration_progress_message(calibration_axis, calibration_progress, calibration_status)

        def gimbal_axis_calibration_progress_send(self, calibration_axis, calibration_progress, calibration_status):
                '''
                Reports progress and success or failure of gimbal axis calibration
                procedure

                calibration_axis          : Which gimbal axis we're reporting calibration progress for (uint8_t)
                calibration_progress        : The current calibration progress for this axis, 0x64=100% (uint8_t)
                calibration_status        : The status of the running calibration (uint8_t)

                '''
                return self.send(self.gimbal_axis_calibration_progress_encode(calibration_axis, calibration_progress, calibration_status))

        def gimbal_set_home_offsets_encode(self, target_system, target_component):
                '''
                Instructs the gimbal to set its current position as its new home
                position.  Will primarily be used for factory
                calibration

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_gimbal_set_home_offsets_message(target_system, target_component)

        def gimbal_set_home_offsets_send(self, target_system, target_component):
                '''
                Instructs the gimbal to set its current position as its new home
                position.  Will primarily be used for factory
                calibration

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.gimbal_set_home_offsets_encode(target_system, target_component))

        def gimbal_home_offset_calibration_result_encode(self, calibration_result):
                '''
                Sent by the gimbal after it receives a SET_HOME_OFFSETS message to
                indicate the result of the home offset calibration

                calibration_result        : The result of the home offset calibration (uint8_t)

                '''
                return MAVLink_gimbal_home_offset_calibration_result_message(calibration_result)

        def gimbal_home_offset_calibration_result_send(self, calibration_result):
                '''
                Sent by the gimbal after it receives a SET_HOME_OFFSETS message to
                indicate the result of the home offset calibration

                calibration_result        : The result of the home offset calibration (uint8_t)

                '''
                return self.send(self.gimbal_home_offset_calibration_result_encode(calibration_result))

        def gimbal_set_factory_parameters_encode(self, target_system, target_component, magic_1, magic_2, magic_3, assembly_year, assembly_month, assembly_day, assembly_hour, assembly_minute, assembly_second, serial_number_pt_1, serial_number_pt_2, serial_number_pt_3):
                '''
                Set factory configuration parameters (such as assembly date and time,
                and serial number).  This is only intended to be used
                during manufacture, not by end users, so it is
                protected by a simple checksum of sorts (this won't
                stop anybody determined,             it's mostly just
                to keep the average user from trying to modify these
                values.  This will need to be revisited if that isn't
                adequate.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                magic_1                   : Magic number 1 for validation (uint32_t)
                magic_2                   : Magic number 2 for validation (uint32_t)
                magic_3                   : Magic number 3 for validation (uint32_t)
                assembly_year             : Assembly Date Year (uint16_t)
                assembly_month            : Assembly Date Month (uint8_t)
                assembly_day              : Assembly Date Day (uint8_t)
                assembly_hour             : Assembly Time Hour (uint8_t)
                assembly_minute           : Assembly Time Minute (uint8_t)
                assembly_second           : Assembly Time Second (uint8_t)
                serial_number_pt_1        : Unit Serial Number Part 1 (part code, design, language/country) (uint32_t)
                serial_number_pt_2        : Unit Serial Number Part 2 (option, year, month) (uint32_t)
                serial_number_pt_3        : Unit Serial Number Part 3 (incrementing serial number per month) (uint32_t)

                '''
                return MAVLink_gimbal_set_factory_parameters_message(target_system, target_component, magic_1, magic_2, magic_3, assembly_year, assembly_month, assembly_day, assembly_hour, assembly_minute, assembly_second, serial_number_pt_1, serial_number_pt_2, serial_number_pt_3)

        def gimbal_set_factory_parameters_send(self, target_system, target_component, magic_1, magic_2, magic_3, assembly_year, assembly_month, assembly_day, assembly_hour, assembly_minute, assembly_second, serial_number_pt_1, serial_number_pt_2, serial_number_pt_3):
                '''
                Set factory configuration parameters (such as assembly date and time,
                and serial number).  This is only intended to be used
                during manufacture, not by end users, so it is
                protected by a simple checksum of sorts (this won't
                stop anybody determined,             it's mostly just
                to keep the average user from trying to modify these
                values.  This will need to be revisited if that isn't
                adequate.

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                magic_1                   : Magic number 1 for validation (uint32_t)
                magic_2                   : Magic number 2 for validation (uint32_t)
                magic_3                   : Magic number 3 for validation (uint32_t)
                assembly_year             : Assembly Date Year (uint16_t)
                assembly_month            : Assembly Date Month (uint8_t)
                assembly_day              : Assembly Date Day (uint8_t)
                assembly_hour             : Assembly Time Hour (uint8_t)
                assembly_minute           : Assembly Time Minute (uint8_t)
                assembly_second           : Assembly Time Second (uint8_t)
                serial_number_pt_1        : Unit Serial Number Part 1 (part code, design, language/country) (uint32_t)
                serial_number_pt_2        : Unit Serial Number Part 2 (option, year, month) (uint32_t)
                serial_number_pt_3        : Unit Serial Number Part 3 (incrementing serial number per month) (uint32_t)

                '''
                return self.send(self.gimbal_set_factory_parameters_encode(target_system, target_component, magic_1, magic_2, magic_3, assembly_year, assembly_month, assembly_day, assembly_hour, assembly_minute, assembly_second, serial_number_pt_1, serial_number_pt_2, serial_number_pt_3))

        def gimbal_factory_parameters_loaded_encode(self, dummy):
                '''
                Sent by the gimbal after the factory parameters are successfully
                loaded, to inform the factory software that the load
                is complete

                dummy                     : Dummy field because mavgen doesn't allow messages with no fields (uint8_t)

                '''
                return MAVLink_gimbal_factory_parameters_loaded_message(dummy)

        def gimbal_factory_parameters_loaded_send(self, dummy):
                '''
                Sent by the gimbal after the factory parameters are successfully
                loaded, to inform the factory software that the load
                is complete

                dummy                     : Dummy field because mavgen doesn't allow messages with no fields (uint8_t)

                '''
                return self.send(self.gimbal_factory_parameters_loaded_encode(dummy))

        def gimbal_erase_firmware_and_config_encode(self, target_system, target_component, knock):
                '''
                Commands the gimbal to erase its firmware image and flash
                configuration, leaving only the bootloader.  The
                gimbal will then reboot into the bootloader,
                ready for the load of a new application firmware
                image.  Erasing the flash configuration will cause the
                gimbal to re-perform axis calibration when a
                new firmware image is loaded, and will cause all
                tuning parameters to return to their factory defaults.
                WARNING: sending this command will render a
                gimbal inoperable until a new firmware image is loaded
                onto it.  For this reason, a particular "knock" value
                must be sent for the command to take effect.
                Use this command at your own risk

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                knock                     : Knock value to confirm this is a valid request (uint32_t)

                '''
                return MAVLink_gimbal_erase_firmware_and_config_message(target_system, target_component, knock)

        def gimbal_erase_firmware_and_config_send(self, target_system, target_component, knock):
                '''
                Commands the gimbal to erase its firmware image and flash
                configuration, leaving only the bootloader.  The
                gimbal will then reboot into the bootloader,
                ready for the load of a new application firmware
                image.  Erasing the flash configuration will cause the
                gimbal to re-perform axis calibration when a
                new firmware image is loaded, and will cause all
                tuning parameters to return to their factory defaults.
                WARNING: sending this command will render a
                gimbal inoperable until a new firmware image is loaded
                onto it.  For this reason, a particular "knock" value
                must be sent for the command to take effect.
                Use this command at your own risk

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                knock                     : Knock value to confirm this is a valid request (uint32_t)

                '''
                return self.send(self.gimbal_erase_firmware_and_config_encode(target_system, target_component, knock))

        def gimbal_perform_factory_tests_encode(self, target_system, target_component):
                '''
                Command the gimbal to perform a series of factory tests.  Should not
                be needed by end users

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_gimbal_perform_factory_tests_message(target_system, target_component)

        def gimbal_perform_factory_tests_send(self, target_system, target_component):
                '''
                Command the gimbal to perform a series of factory tests.  Should not
                be needed by end users

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.gimbal_perform_factory_tests_encode(target_system, target_component))

        def gimbal_report_factory_tests_progress_encode(self, test, test_section, test_section_progress, test_status):
                '''
                Reports the current status of a section of a running factory test

                test                      : Which factory test is currently running (uint8_t)
                test_section              : Which section of the test is currently running.  The meaning of this is test-dependent (uint8_t)
                test_section_progress        : The progress of the current test section, 0x64=100% (uint8_t)
                test_status               : The status of the currently executing test section.  The meaning of this is test and section-dependent (uint8_t)

                '''
                return MAVLink_gimbal_report_factory_tests_progress_message(test, test_section, test_section_progress, test_status)

        def gimbal_report_factory_tests_progress_send(self, test, test_section, test_section_progress, test_status):
                '''
                Reports the current status of a section of a running factory test

                test                      : Which factory test is currently running (uint8_t)
                test_section              : Which section of the test is currently running.  The meaning of this is test-dependent (uint8_t)
                test_section_progress        : The progress of the current test section, 0x64=100% (uint8_t)
                test_status               : The status of the currently executing test section.  The meaning of this is test and section-dependent (uint8_t)

                '''
                return self.send(self.gimbal_report_factory_tests_progress_encode(test, test_section, test_section_progress, test_status))

        def gopro_power_on_encode(self, target_system, target_component):
                '''
                Instruct a HeroBus attached GoPro to power on

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_gopro_power_on_message(target_system, target_component)

        def gopro_power_on_send(self, target_system, target_component):
                '''
                Instruct a HeroBus attached GoPro to power on

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.gopro_power_on_encode(target_system, target_component))

        def gopro_power_off_encode(self, target_system, target_component):
                '''
                Instruct a HeroBus attached GoPro to power off

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return MAVLink_gopro_power_off_message(target_system, target_component)

        def gopro_power_off_send(self, target_system, target_component):
                '''
                Instruct a HeroBus attached GoPro to power off

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)

                '''
                return self.send(self.gopro_power_off_encode(target_system, target_component))

        def gopro_command_encode(self, target_system, target_component, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_parm):
                '''
                Send a command to a HeroBus attached GoPro.  Will generate a
                GOPRO_RESPONSE message with results of the command

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                gp_cmd_name_1             : First character of the 2 character GoPro command (uint8_t)
                gp_cmd_name_2             : Second character of the 2 character GoPro command (uint8_t)
                gp_cmd_parm               : Parameter for the command (uint8_t)

                '''
                return MAVLink_gopro_command_message(target_system, target_component, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_parm)

        def gopro_command_send(self, target_system, target_component, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_parm):
                '''
                Send a command to a HeroBus attached GoPro.  Will generate a
                GOPRO_RESPONSE message with results of the command

                target_system             : System ID (uint8_t)
                target_component          : Component ID (uint8_t)
                gp_cmd_name_1             : First character of the 2 character GoPro command (uint8_t)
                gp_cmd_name_2             : Second character of the 2 character GoPro command (uint8_t)
                gp_cmd_parm               : Parameter for the command (uint8_t)

                '''
                return self.send(self.gopro_command_encode(target_system, target_component, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_parm))

        def gopro_response_encode(self, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_response_status, gp_cmd_response_argument, gp_cmd_result):
                '''
                Response to a command sent to a HeroBus attached GoPro with a
                GOPRO_COMMAND message.  Contains response from the
                camera as well as information about any errors
                encountered while attempting to communicate with the
                camera

                gp_cmd_name_1             : First character of the 2 character GoPro command that generated this response (uint8_t)
                gp_cmd_name_2             : Second character of the 2 character GoPro command that generated this response (uint8_t)
                gp_cmd_response_status        : Response byte from the GoPro's response to the command.  0 = Success, 1 = Failure (uint8_t)
                gp_cmd_response_argument        : Response argument from the GoPro's response to the command (uint8_t)
                gp_cmd_result             : Result of the command attempt to the GoPro, as defined by GOPRO_CMD_RESULT enum. (uint16_t)

                '''
                return MAVLink_gopro_response_message(gp_cmd_name_1, gp_cmd_name_2, gp_cmd_response_status, gp_cmd_response_argument, gp_cmd_result)

        def gopro_response_send(self, gp_cmd_name_1, gp_cmd_name_2, gp_cmd_response_status, gp_cmd_response_argument, gp_cmd_result):
                '''
                Response to a command sent to a HeroBus attached GoPro with a
                GOPRO_COMMAND message.  Contains response from the
                camera as well as information about any errors
                encountered while attempting to communicate with the
                camera

                gp_cmd_name_1             : First character of the 2 character GoPro command that generated this response (uint8_t)
                gp_cmd_name_2             : Second character of the 2 character GoPro command that generated this response (uint8_t)
                gp_cmd_response_status        : Response byte from the GoPro's response to the command.  0 = Success, 1 = Failure (uint8_t)
                gp_cmd_response_argument        : Response argument from the GoPro's response to the command (uint8_t)
                gp_cmd_result             : Result of the command attempt to the GoPro, as defined by GOPRO_CMD_RESULT enum. (uint16_t)

                '''
                return self.send(self.gopro_response_encode(gp_cmd_name_1, gp_cmd_name_2, gp_cmd_response_status, gp_cmd_response_argument, gp_cmd_result))

